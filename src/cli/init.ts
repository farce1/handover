import * as p from '@clack/prompts';
import pc from 'picocolors';
import { writeFileSync, existsSync, readFileSync } from 'node:fs';
import { stringify as stringifyYaml } from 'yaml';
import { HandoverConfigSchema } from '../config/schema.js';
import { DEFAULT_API_KEY_ENV } from '../config/defaults.js';

/**
 * Interactive init flow using @clack/prompts.
 * Creates .handover.yml with polished UX (CONTEXT.md: "feel like create-next-app").
 *
 * Minimal questions: just provider + API key env var.
 * Everything else auto-detected.
 */
export async function runInit(): Promise<void> {
  p.intro(pc.bgCyan(pc.black(' handover init ')));

  // Check for existing config
  if (existsSync('.handover.yml')) {
    const overwrite = await p.confirm({
      message: '.handover.yml already exists. Overwrite?',
      initialValue: false,
    });
    if (p.isCancel(overwrite) || !overwrite) {
      p.cancel('Keeping existing config.');
      return;
    }
  }

  const answers = await p.group(
    {
      provider: () =>
        p.select({
          message: 'Which LLM provider?',
          options: [
            {
              value: 'anthropic' as const,
              label: 'Anthropic',
              hint: 'Claude Opus — recommended',
            },
            {
              value: 'openai' as const,
              label: 'OpenAI',
              hint: 'GPT-4o',
            },
            {
              value: 'ollama' as const,
              label: 'Ollama',
              hint: 'Local models — zero external data transfer',
            },
            {
              value: 'gemini' as const,
              label: 'Google Gemini',
              hint: 'Gemini 2.5 Flash — generous free tier',
            },
          ],
        }),
      apiKeyEnv: ({ results }) => {
        if (results.provider === 'ollama') {
          return Promise.resolve('');
        }
        const defaultEnv = DEFAULT_API_KEY_ENV[results.provider as string] ?? 'LLM_API_KEY';
        return p.text({
          message: `Environment variable for API key:`,
          initialValue: defaultEnv,
          validate: (v) => {
            if (!v && results.provider !== 'ollama') return 'Required for cloud providers';
          },
        });
      },
    },
    {
      onCancel: () => {
        p.cancel('Setup cancelled.');
        process.exit(0);
      },
    },
  );

  // Auto-detect project info
  const s = p.spinner();
  s.start('Detecting project...');

  const projectInfo = detectProject();

  s.stop(`Detected: ${pc.cyan(projectInfo.name)} (${projectInfo.language})`);

  // Build config
  const config: Record<string, unknown> = {
    provider: answers.provider,
  };

  // Only add apiKeyEnv if non-default
  const defaultEnv = DEFAULT_API_KEY_ENV[answers.provider] ?? '';
  if (answers.apiKeyEnv && answers.apiKeyEnv !== defaultEnv) {
    config.apiKeyEnv = answers.apiKeyEnv;
  }

  // Add detected project info
  if (projectInfo.name) {
    config.project = { name: projectInfo.name };
  }

  // Validate through schema
  const validated = HandoverConfigSchema.parse(config);

  // Write YAML with header comment
  const yamlContent = [
    '# handover configuration',
    '# Generated by `handover init`',
    `# Docs: https://github.com/handover/handover`,
    '',
    stringifyYaml(config, { lineWidth: 80 }),
  ].join('\n');

  writeFileSync('.handover.yml', yamlContent, 'utf-8');

  // Show summary
  p.note(
    [
      `${pc.dim('Provider:')} ${pc.cyan(validated.provider)}`,
      `${pc.dim('Model:')}    ${pc.cyan(validated.model ?? 'default')}`,
      `${pc.dim('Output:')}   ${pc.cyan(validated.output)}`,
      `${pc.dim('Config:')}   ${pc.cyan('.handover.yml')}`,
    ].join('\n'),
    'Configuration',
  );

  p.outro(`Run ${pc.cyan('handover generate')} to analyze your codebase`);
}

/**
 * Auto-detect project information from the filesystem.
 */
function detectProject(): { name: string; language: string } {
  let name = 'project';
  let language = 'unknown';

  // Try package.json first
  if (existsSync('package.json')) {
    try {
      const pkg = JSON.parse(readFileSync('package.json', 'utf-8'));
      name = pkg.name ?? name;
      language = 'typescript';
    } catch {
      // Ignore parse errors in existing config — treat as if no config exists; user will re-configure
    }
  }

  // Detect language from files if not from package.json
  if (language === 'unknown') {
    if (existsSync('tsconfig.json')) language = 'typescript';
    else if (existsSync('pyproject.toml') || existsSync('setup.py')) language = 'python';
    else if (existsSync('Cargo.toml')) language = 'rust';
    else if (existsSync('go.mod')) language = 'go';
    else if (existsSync('package.json')) language = 'javascript';
  }

  // Fallback name from directory
  if (name === 'project') {
    name = process.cwd().split('/').pop() ?? 'project';
  }

  return { name, language };
}
