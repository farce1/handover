---
phase: 12-vector-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/schema.ts
  - src/vector/types.ts
  - src/vector/schema.ts
  - src/vector/vector-store.ts
autonomous: true

must_haves:
  truths:
    - 'SQLite database with vec0 virtual table is created at .handover/search.db on first reindex'
    - 'Embedding model name and dimension count are stored in schema_metadata table'
    - 'Startup validation detects embedding model mismatch and throws error with remediation steps'
    - 'Handover config accepts optional embedding.provider and embedding.model fields'
  artifacts:
    - path: 'src/config/schema.ts'
      provides: 'Embedding config section in HandoverConfigSchema'
      contains: 'embedding'
    - path: 'src/vector/types.ts'
      provides: 'Chunk, ChunkMetadata, EmbeddingResult, and VectorStoreConfig interfaces'
      exports: ['ChunkMetadata', 'EmbeddingResult', 'VectorStoreConfig']
    - path: 'src/vector/schema.ts'
      provides: 'Database schema creation, migration, and dimension validation logic'
      exports: ['initSchema', 'validateEmbeddingDimensions']
    - path: 'src/vector/vector-store.ts'
      provides: 'VectorStore class wrapping SQLite + sqlite-vec for CRUD operations'
      exports: ['VectorStore']
  key_links:
    - from: 'src/vector/schema.ts'
      to: 'src/vector/types.ts'
      via: 'imports VectorStoreConfig for dimension/model info'
      pattern: 'import.*VectorStoreConfig.*from.*types'
    - from: 'src/vector/vector-store.ts'
      to: 'src/vector/schema.ts'
      via: 'calls initSchema and validateEmbeddingDimensions on open'
      pattern: '(initSchema|validateEmbeddingDimensions)'
    - from: 'src/config/schema.ts'
      to: 'src/vector/types.ts'
      via: 'embedding config shape feeds VectorStoreConfig'
      pattern: 'embedding'
---

<objective>
Create the vector storage foundation: config schema extension for embedding settings, TypeScript type definitions for chunks/embeddings, SQLite database schema with sqlite-vec vec0 virtual table, and a VectorStore class for database lifecycle management (create, open, validate, insert, delete, close).

Purpose: Provides the data layer that all other Phase 12 plans build on. Without the database and type system, the chunker and embedder have nowhere to store results.

Output: Config schema with embedding section, vector type definitions, database schema module, and VectorStore class.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/config/schema.ts
@src/providers/base-provider.ts
@src/providers/base.ts
@src/providers/factory.ts
@src/cache/round-cache.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config schema extension and vector type definitions</name>
  <files>
    src/config/schema.ts
    src/vector/types.ts
  </files>
  <action>
**1. Extend HandoverConfigSchema in `src/config/schema.ts`:**

Add an optional `embedding` section to the config schema:

```typescript
embedding: z.object({
  provider: z.enum(['openai']).default('openai'),
  model: z.string().default('text-embedding-3-small'),
  apiKeyEnv: z.string().optional(),
  batchSize: z.number().int().positive().default(100),
}).optional(),
```

This follows the existing pattern of optional config sections (like `analysis`, `contextWindow`). The `provider` enum starts with `openai` only (per locked decision: cloud-only providers for now). The `apiKeyEnv` allows overriding the env var name (default falls back to `OPENAI_API_KEY`).

**2. Create `src/vector/types.ts`:**

Define all TypeScript interfaces for the vector storage subsystem:

- `ChunkMetadata`: `{ sourceFile: string; docId: string; docType: string; sectionPath: string; chunkIndex: number; h1?: string; h2?: string; h3?: string; tokenCount: number; contentPreview: string; }`
- `DocumentChunk`: `{ content: string; metadata: ChunkMetadata; }`
- `StoredChunk`: extends DocumentChunk with `{ rowid: number; embedding: Float32Array; }`
- `EmbeddingResult`: `{ embeddings: number[][]; model: string; dimensions: number; usage: { totalTokens: number; }; }`
- `VectorStoreConfig`: `{ dbPath: string; embeddingModel: string; embeddingDimensions: number; }`
- `DocumentFingerprint`: `{ docId: string; fingerprint: string; indexedAt: string; chunkCount: number; }`
- `SchemaMetadata`: `{ schemaVersion: number; embeddingModel: string; embeddingDimensions: number; createdAt: string; }`

Use `export interface` for all types. Add JSDoc comments explaining the purpose of each interface and field. Use the naming conventions from CONVENTIONS.md (PascalCase interfaces, camelCase fields).

Also export constants:

- `SCHEMA_VERSION = 1`
- `DEFAULT_EMBEDDING_MODEL = 'text-embedding-3-small'`
- `DEFAULT_EMBEDDING_DIMENSIONS = 1536`
- `EMBEDDING_MODELS: Record<string, number>` mapping model names to their dimension counts: `{ 'text-embedding-3-small': 1536, 'text-embedding-3-large': 3072, 'text-embedding-ada-002': 1536 }`
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. Verify `src/vector/types.ts` exports all interfaces. Verify `src/config/schema.ts` parses with the new embedding field (write a quick inline check or rely on existing config loader tests).
  </verify>
  <done>
  HandoverConfigSchema has optional `embedding` section. All vector type interfaces are exported from `src/vector/types.ts`. TypeScript compiles cleanly.
  </done>
  </task>

<task type="auto">
  <name>Task 2: SQLite schema module and VectorStore class</name>
  <files>
    src/vector/schema.ts
    src/vector/vector-store.ts
  </files>
  <action>
**Install dependencies first:**

```bash
npm install better-sqlite3 sqlite-vec
npm install --save-dev @types/better-sqlite3
```

better-sqlite3 is the synchronous SQLite driver ideal for CLI tools (no async overhead). sqlite-vec is the zero-dependency C extension for vector search.

**1. Create `src/vector/schema.ts`:**

Database schema creation and validation module.

`initSchema(db: Database, config: VectorStoreConfig): void` — Creates tables if they don't exist:

```sql
CREATE TABLE IF NOT EXISTS schema_metadata (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS document_metadata (
  doc_id TEXT PRIMARY KEY,
  fingerprint TEXT NOT NULL,
  indexed_at TEXT NOT NULL,
  chunk_count INTEGER NOT NULL DEFAULT 0
);
```

For the vec0 virtual table, use the dimension from config:

```sql
CREATE VIRTUAL TABLE IF NOT EXISTS vec_chunks USING vec0(
  embedding float[${config.embeddingDimensions}],
  doc_id TEXT NOT NULL,
  doc_type TEXT NOT NULL,
  source_file TEXT NOT NULL,
  chunk_index INTEGER NOT NULL,
  +section_path TEXT,
  +h1 TEXT,
  +h2 TEXT,
  +h3 TEXT,
  +token_count INTEGER,
  +content_preview TEXT,
  +content TEXT
);
```

Note: Include `+content TEXT` as an auxiliary column to store the actual chunk text for retrieval (downstream search needs it). Auxiliary columns (prefixed with `+`) are stored but not indexed.

After table creation, insert or verify schema_metadata entries for `schema_version`, `embedding_model`, `embedding_dimensions`, and `created_at`.

`validateEmbeddingDimensions(db: Database, currentModel: string, currentDimensions: number): void` — Reads `embedding_model` and `embedding_dimensions` from schema_metadata. If the stored model differs from currentModel AND the dimensions differ, throw an Error with a clear remediation message:

```
Embedding model mismatch detected!

Database was created with: text-embedding-3-small (1536 dimensions)
Current config uses: text-embedding-3-large (3072 dimensions)

To rebuild the vector database with the new model:
  1. Delete .handover/search.db
  2. Run: handover reindex

Warning: This will re-embed all documents (may incur API costs).
```

If the model changed but dimensions are the same, update the stored model silently (e.g., model alias change). If the database has no schema_metadata entries yet (first run), skip validation and populate metadata.

`getSchemaMetadata(db: Database): SchemaMetadata | null` — Read current schema metadata. Returns null if table is empty.

**2. Create `src/vector/vector-store.ts`:**

`VectorStore` class — wraps better-sqlite3 + sqlite-vec:

Constructor takes `config: VectorStoreConfig`. On construction, does NOT open the database.

`open(): void` — Opens the database file, loads the sqlite-vec extension via `db.loadExtension(sqliteVec.getLoadablePath())`, calls `initSchema()`, calls `validateEmbeddingDimensions()`. Ensures `.handover/` directory exists (create with `mkdirSync` if needed).

`close(): void` — Closes the database connection.

`insertChunks(chunks: DocumentChunk[], embeddings: number[][]): void` — Inserts chunk+embedding pairs into vec_chunks using a prepared statement inside a transaction. For each chunk: serialize the embedding as a JSON array string (sqlite-vec accepts `[0.1, 0.2, ...]` format for float vectors). Map metadata fields to the appropriate columns. Use `db.transaction()` for atomicity.

`deleteDocumentChunks(docId: string): number` — Deletes all chunks for a given doc_id. Returns the number of deleted rows. Use `DELETE FROM vec_chunks WHERE doc_id = ?`.

`getDocumentFingerprint(docId: string): DocumentFingerprint | null` — Query document_metadata for the stored fingerprint.

`upsertDocumentFingerprint(fingerprint: DocumentFingerprint): void` — INSERT OR REPLACE into document_metadata.

`getChunkCount(): number` — Returns total row count from vec_chunks.

`getDocumentCount(): number` — Returns count of distinct doc_ids in document_metadata.

**Important implementation notes:**

- Use `import * as sqliteVec from 'sqlite-vec'` to load the extension path.
- Use `import Database from 'better-sqlite3'` for the SQLite driver.
- Log to stderr (not stdout) using `logger.log()` from `src/utils/logger.ts` — this is critical for future MCP server use where stdout is reserved for the protocol (per pitfall in STATE.md).
- Wrap the extension loading in try/catch with a clear error message if sqlite-vec fails to load (e.g., unsupported platform).
- The database path defaults to `path.join(config.output || './handover', 'search.db')` but is configurable via VectorStoreConfig.dbPath.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. Write a quick smoke test or use `node -e "..."` to verify:

1. `better-sqlite3` and `sqlite-vec` are importable
2. A VectorStore can be instantiated, opened (creates `.handover/search.db`), and closed
3. Schema tables exist after open (`schema_metadata`, `document_metadata`, `vec_chunks`)
4. Dimension validation throws on mismatch
   </verify>
   <done>
   VectorStore class creates SQLite database at `.handover/search.db` with vec0 virtual table. Schema metadata stores embedding model and dimensions. Dimension validation detects mismatches and throws with remediation instructions. All CRUD operations (insert/delete chunks, get/upsert fingerprints) work.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm test` passes (no regressions in existing 254 tests)
3. HandoverConfigSchema accepts `embedding: { provider: 'openai', model: 'text-embedding-3-small' }`
4. VectorStore.open() creates `.handover/search.db` with expected schema
5. VectorStore dimension validation throws on model mismatch
6. All vector types are exported from `src/vector/types.ts`
</verification>

<success_criteria>

- Config schema extended with optional embedding section
- All vector type interfaces defined and exported
- SQLite database with vec0 virtual table created at .handover/search.db
- Schema metadata stores and validates embedding model + dimensions
- VectorStore class provides full CRUD interface for chunks and fingerprints
- TypeScript compiles cleanly, existing tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/12-vector-storage-foundation/12-01-SUMMARY.md`
</output>
