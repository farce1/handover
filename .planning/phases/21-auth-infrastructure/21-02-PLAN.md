---
phase: 21-auth-infrastructure
plan: 02
type: tdd
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/config/schema.ts
  - src/config/schema.test.ts
  - src/auth/resolve.ts
  - src/auth/resolve.test.ts
  - src/auth/index.ts
autonomous: true

must_haves:
  truths:
    - "authMethod field in .handover.yml defaults to 'api-key' without breaking existing configs"
    - "Anthropic + subscription combination is rejected at schema validation with clear message"
    - "resolveAuth returns CLI --api-key flag as highest precedence"
    - "resolveAuth returns env var as second precedence (even if authMethod is subscription)"
    - "resolveAuth returns credential store token when authMethod is subscription and no env var set"
    - "resolveAuth does NOT check credential store when authMethod is api-key"
    - "resolveAuth short-circuits for local providers (Ollama) without prompting"
    - "resolveAuth throws AuthError with all options listed in non-interactive mode (no TTY / CI)"
    - "resolveAuth always logs which auth source was used"
    - "src/auth/index.ts re-exports all public types and functions with no circular dependencies"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "authMethod field added to HandoverConfigSchema"
      contains: "authMethod"
    - path: "src/config/schema.test.ts"
      provides: "Tests for authMethod default, Anthropic+subscription rejection"
      contains: "authMethod"
    - path: "src/auth/resolve.ts"
      provides: "resolveAuth() function implementing four-step precedence"
      exports: ["resolveAuth"]
    - path: "src/auth/resolve.test.ts"
      provides: "Tests for all four precedence steps, local provider short-circuit, non-interactive error"
    - path: "src/auth/index.ts"
      provides: "Barrel re-export of all src/auth/ public API"
      exports: ["AuthError", "AuthResult", "AuthSource", "StoredCredential", "TokenStore", "resolveAuth"]
  key_links:
    - from: "src/auth/resolve.ts"
      to: "src/auth/token-store.ts"
      via: "reads credential store in precedence step 3"
      pattern: "store\\.read\\(\\)"
    - from: "src/auth/resolve.ts"
      to: "src/auth/types.ts"
      via: "returns AuthResult, throws AuthError"
      pattern: "AuthResult|AuthError"
    - from: "src/auth/resolve.ts"
      to: "src/config/defaults.ts"
      via: "looks up DEFAULT_API_KEY_ENV for provider"
      pattern: "DEFAULT_API_KEY_ENV"
    - from: "src/auth/resolve.ts"
      to: "src/providers/presets.ts"
      via: "checks preset.isLocal for Ollama short-circuit"
      pattern: "PROVIDER_PRESETS.*isLocal"
    - from: "src/auth/index.ts"
      to: "src/auth/types.ts"
      via: "re-exports types"
      pattern: "export.*from.*types"
    - from: "src/auth/index.ts"
      to: "src/auth/token-store.ts"
      via: "re-exports TokenStore"
      pattern: "export.*from.*token-store"
    - from: "src/auth/index.ts"
      to: "src/auth/resolve.ts"
      via: "re-exports resolveAuth"
      pattern: "export.*from.*resolve"
    - from: "src/config/schema.ts"
      to: "zod"
      via: "superRefine for Anthropic constraint"
      pattern: "superRefine"
---

<objective>
Add the `authMethod` field to the config schema with Anthropic constraint validation, implement `resolveAuth()` with four-step precedence, and create the barrel `src/auth/index.ts` that exports the complete auth module API.

Purpose: This completes the auth infrastructure. After this plan, any auth-dependent code can `import { resolveAuth, AuthResult, TokenStore } from '../auth/index.js'` and get the full precedence chain with logging. The schema change ensures existing `.handover.yml` files continue working (defaults to `"api-key"`) while enabling subscription auth for non-Anthropic providers.

Output: Modified `src/config/schema.ts`, new `src/auth/resolve.ts`, new `src/auth/index.ts`, with full test coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-auth-infrastructure/21-RESEARCH.md
@.planning/phases/21-auth-infrastructure/21-01-SUMMARY.md
@src/config/schema.ts
@src/config/schema.test.ts
@src/config/defaults.ts
@src/config/loader.ts
@src/providers/presets.ts
@src/utils/errors.ts
@src/utils/logger.ts
@src/auth/types.ts
@src/auth/token-store.ts
@vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add authMethod field to config schema with Anthropic constraint (TDD)</name>
  <files>src/config/schema.ts, src/config/schema.test.ts</files>
  <action>
**RED phase first — write failing tests in the existing test file, then GREEN — modify schema to pass.**

Add tests to `src/config/schema.test.ts` (append new describe blocks to existing file):

1. **authMethod defaults to 'api-key':**
   ```typescript
   describe('authMethod field', () => {
     test('defaults to api-key when not specified', () => {
       const result = HandoverConfigSchema.safeParse({});
       expect(result.success).toBe(true);
       if (!result.success) return;
       expect(result.data.authMethod).toBe('api-key');
     });
   ```
2. **authMethod accepts 'api-key':**
   - `safeParse({ authMethod: 'api-key' })` succeeds
3. **authMethod accepts 'subscription':**
   - `safeParse({ authMethod: 'subscription' })` succeeds
4. **authMethod rejects invalid values:**
   - `safeParse({ authMethod: 'oauth' })` fails
5. **Anthropic + subscription is rejected via superRefine:**
   - `safeParse({ provider: 'anthropic', authMethod: 'subscription' })` fails
   - Error message contains "Anthropic does not support subscription auth"
   - Error path is `['authMethod']`
6. **Anthropic + api-key is accepted:**
   - `safeParse({ provider: 'anthropic', authMethod: 'api-key' })` succeeds
7. **OpenAI + subscription is accepted:**
   - `safeParse({ provider: 'openai', authMethod: 'subscription' })` succeeds
8. **Existing empty config still works (regression):**
   - `safeParse({})` still returns all original defaults (provider: 'anthropic', output: './handover', etc.)

Run tests — they should FAIL because `authMethod` doesn't exist yet.

Then modify `src/config/schema.ts`:

1. Add `authMethod: z.enum(['api-key', 'subscription']).default('api-key')` to `HandoverConfigSchema`'s `z.object({...})` — place it right after the `provider` field for logical grouping.

2. Convert the `z.object({...})` to use `.superRefine()` at the end (the schema currently does NOT have superRefine — only `EmbeddingConfigSchema` does). Add:
   ```typescript
   .superRefine((value, ctx) => {
     if (value.provider === 'anthropic' && value.authMethod === 'subscription') {
       ctx.addIssue({
         code: z.ZodIssueCode.custom,
         path: ['authMethod'],
         message: 'Anthropic does not support subscription auth — use authMethod: api-key',
       });
     }
   });
   ```

3. **IMPORTANT:** The current schema is `export const HandoverConfigSchema = z.object({...})` — you need to add `.superRefine()` after the closing `})`. The `HandoverConfig` type inference `z.infer<typeof HandoverConfigSchema>` will still work correctly because Zod types propagate through superRefine.

4. Verify the existing `safeParse({})` test still passes — the `authMethod` default ensures backward compatibility.

Run `npx vitest run src/config/schema.test.ts` — all tests should pass.
  </action>
  <verify>npx vitest run src/config/schema.test.ts --reporter=verbose</verify>
  <done>authMethod field defaults to 'api-key'. Anthropic+subscription rejected with clear message. All existing schema tests still pass (no regression). HandoverConfig type includes authMethod.</done>
</task>

<task type="auto">
  <name>Task 2: Implement resolveAuth() with precedence chain and barrel export (TDD)</name>
  <files>src/auth/resolve.ts, src/auth/resolve.test.ts, src/auth/index.ts</files>
  <action>
**RED phase first — write failing tests, then GREEN — implement to pass.**

Create `src/auth/resolve.test.ts`:

**Test setup — mock dependencies:**
```typescript
import { vi, describe, test, expect, beforeEach, afterEach } from 'vitest';
import type { HandoverConfig } from '../config/schema.js';
```

Mock the logger to capture log calls:
```typescript
const mockLogger = { info: vi.fn(), warn: vi.fn(), debug: vi.fn() };
vi.mock('../utils/logger.js', () => ({ logger: mockLogger }));
```

Mock `@clack/prompts` for TTY/CI detection and interactive prompt:
```typescript
const mockClack = {
  isTTY: vi.fn(() => true),
  isCI: vi.fn(() => false),
  password: vi.fn(),
};
vi.mock('@clack/prompts', () => mockClack);
```

Create a mock TokenStore for tests:
```typescript
function createMockStore(credential: StoredCredential | null = null) {
  return {
    read: vi.fn(async () => credential),
    write: vi.fn(async () => {}),
    delete: vi.fn(async () => {}),
  } as unknown as TokenStore;
}
```

Helper to create minimal config:
```typescript
function makeConfig(overrides: Partial<HandoverConfig> = {}): HandoverConfig {
  return {
    provider: 'openai',
    authMethod: 'api-key',
    // ... minimal required fields from HandoverConfigSchema defaults
    ...overrides,
  } as HandoverConfig;
}
```

**Tests to write (each in own describe block):**

1. **Precedence Step 1 — CLI flag wins:**
   - Call `resolveAuth(config, 'cli-key-123', mockStore)`
   - Assert result: `{ apiKey: 'cli-key-123', source: 'cli-flag' }`
   - Assert `logger.info` called with message containing 'api-key' or '--api-key flag'
   - Assert mockStore.read NOT called (short-circuited)

2. **Precedence Step 2 — Env var wins over credential store:**
   - Set `process.env.OPENAI_API_KEY = 'env-key-456'`
   - Store has valid credential
   - Call `resolveAuth(config)` with no CLI key
   - Assert result: `{ apiKey: 'env-key-456', source: 'env-var' }`
   - Assert `logger.info` called with message containing 'OPENAI_API_KEY'
   - Cleanup: `delete process.env.OPENAI_API_KEY` in afterEach

3. **Env var wins even when authMethod is subscription:**
   - Config: `{ provider: 'openai', authMethod: 'subscription' }`
   - Set `process.env.OPENAI_API_KEY = 'env-key-789'`
   - Store has valid subscription token
   - Assert result source is `'env-var'`, NOT `'credential-store'`

4. **Precedence Step 3 — Credential store for subscription:**
   - Config: `{ provider: 'openai', authMethod: 'subscription' }`
   - No env var, no CLI flag
   - Store returns `{ provider: 'openai', token: 'sub-token' }`
   - Assert result: `{ apiKey: 'sub-token', source: 'credential-store' }`

5. **Credential store NOT checked when authMethod is api-key:**
   - Config: `{ provider: 'openai', authMethod: 'api-key' }`
   - No env var, no CLI flag, TTY mode (so it would prompt)
   - Mock password to return 'prompted-key'
   - Assert mockStore.read NOT called
   - Assert result source is `'interactive-prompt'`

6. **Credential store skipped when provider mismatch:**
   - Config: `{ provider: 'openai', authMethod: 'subscription' }`
   - Store returns `{ provider: 'anthropic', token: 'wrong-provider-token' }` (different provider)
   - No env var
   - Mock password to return 'prompted-key'
   - Assert result source is `'interactive-prompt'`, not `'credential-store'`

7. **Precedence Step 4 — Interactive prompt:**
   - No CLI flag, no env var, no credential
   - `isTTY` returns true, `isCI` returns false
   - `password` mock returns `'prompted-key'`
   - Assert result: `{ apiKey: 'prompted-key', source: 'interactive-prompt' }`

8. **Non-interactive mode (no TTY) throws AuthError:**
   - `isTTY` returns false
   - No CLI flag, no env var, no credential
   - Assert throws `AuthError` with code `'AUTH_NO_CREDENTIAL'`
   - Assert error fix contains env var name, auth login command, and handover init

9. **Non-interactive mode (CI) throws AuthError:**
   - `isTTY` returns true but `isCI` returns true
   - Assert throws `AuthError` with code `'AUTH_NO_CREDENTIAL'`

10. **Local provider (Ollama) short-circuits:**
    - Config: `{ provider: 'ollama' }`
    - No env var, no CLI flag
    - Assert result: `{ apiKey: '', source: 'env-var' }` (matches current factory.ts behavior)
    - Assert mockStore.read NOT called
    - Assert password NOT called

11. **Interactive prompt cancelled (user hits Ctrl+C):**
    - `password` mock returns `Symbol('clack:cancel')` (Clack's cancel value) or undefined
    - Assert throws `AuthError` with code `'AUTH_CANCELLED'`

12. **Logging always fires:**
    - For each precedence step, verify `logger.info` was called with a message containing the provider name and the auth method source

Then implement `src/auth/resolve.ts`:

```typescript
import type { HandoverConfig } from '../config/schema.js';
import { TokenStore } from './token-store.js';
import { AuthError } from './types.js';
import type { AuthResult, AuthSource } from './types.js';
import { DEFAULT_API_KEY_ENV } from '../config/defaults.js';
import { PROVIDER_PRESETS } from '../providers/presets.js';
import { logger } from '../utils/logger.js';
import pc from 'picocolors';
import { isTTY, isCI, password, isCancel } from '@clack/prompts';
```

Implementation of `resolveAuth`:
- Signature: `async function resolveAuth(config: HandoverConfig, cliApiKey?: string, store?: TokenStore): Promise<AuthResult>`
- Default `store` to `new TokenStore()` if not provided
- Step 0: Check if provider is local (`PROVIDER_PRESETS[config.provider]?.isLocal`). If true, log and return `{ apiKey: '', source: 'env-var' }`
- Step 1: If `cliApiKey` truthy, log `"Using {provider} API key from --api-key flag"`, return `{ apiKey: cliApiKey, source: 'cli-flag' }`
- Step 2: Look up `DEFAULT_API_KEY_ENV[config.provider]`, read `process.env[envVarName]`. If truthy, log `"Using {provider} API key from {envVarName}"`, return `{ apiKey: envValue, source: 'env-var' }`
- Step 3: If `config.authMethod === 'subscription'`, call `store.read()`. If credential exists and `credential.provider === config.provider`, log `"Using {provider} subscription token from credential store"`, return `{ apiKey: credential.token, source: 'credential-store' }`
- Step 4: Check `!isTTY(process.stdout) || isCI()`. If non-interactive, throw `AuthError.noCredential(config.provider, envVarName)`
- Step 5: Call `password({ message: \`Enter your ${config.provider} API key:\` })`. Check `if (isCancel(entered) || !entered)` — if true, throw new AuthError with code `'AUTH_CANCELLED'`. Otherwise log and return `{ apiKey: entered as string, source: 'interactive-prompt' }`

**IMPORTANT notes from locked decisions:**
- Env var ALWAYS wins, even if `authMethod: subscription` — this is the intentional precedence
- Credential store is ONLY checked for `authMethod: 'subscription'` — never for api-key
- Always log which method was used (every return path has a `logger.info` call)
- Non-interactive error lists ALL options (env var, auth login, handover init) — use `AuthError.noCredential()`
- Color: red for errors, yellow for warnings, bold for commands (via picocolors through AuthError.format())

Then create `src/auth/index.ts` — the barrel export:

```typescript
// Re-export public API
export type { AuthResult, AuthSource, StoredCredential } from './types.js';
export { AuthError } from './types.js';
export { TokenStore } from './token-store.js';
export { resolveAuth } from './resolve.js';
```

Run all auth tests: `npx vitest run src/auth/ --reporter=verbose`
Run all tests: `npx vitest run --reporter=verbose`
Run typecheck: `npx tsc --noEmit`
  </action>
  <verify>npx vitest run src/auth/ --reporter=verbose && npx vitest run src/config/schema.test.ts --reporter=verbose && npx tsc --noEmit</verify>
  <done>resolveAuth follows strict precedence: CLI flag > env var > credential store (subscription only) > interactive prompt. Ollama short-circuits. Non-interactive throws with all options. Logger called on every auth resolution. Schema has authMethod defaulting to api-key. Anthropic+subscription rejected. index.ts re-exports full API. All tests pass. tsc --noEmit clean.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/auth/ --reporter=verbose` — all auth module tests pass
2. `npx vitest run src/config/schema.test.ts --reporter=verbose` — all schema tests pass (including new authMethod tests)
3. `npx vitest run --reporter=verbose` — full test suite passes (no regressions)
4. `npx tsc --noEmit` — clean typecheck, no circular dependency errors
5. Verify import chain is unidirectional: `resolve.ts` -> `token-store.ts` -> `types.ts` -> `../utils/errors.ts` (no cycles)
6. Verify `import { resolveAuth, AuthError, TokenStore, AuthResult } from '../auth/index.js'` works from any consumer
7. Verify `HandoverConfigSchema.safeParse({})` still produces valid config with `authMethod: 'api-key'` (backward compat)
</verification>

<success_criteria>
- authMethod field defaults to 'api-key' in HandoverConfigSchema
- Anthropic + subscription rejected at schema level with clear error message
- resolveAuth() implements full 4-step precedence chain
- Ollama and local providers short-circuit without auth prompting
- Non-interactive mode (CI/piped) throws AuthError listing all auth options
- Auth method source logged on every resolution
- src/auth/index.ts exports complete public API
- No circular dependencies
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-auth-infrastructure/21-02-SUMMARY.md`
</output>
