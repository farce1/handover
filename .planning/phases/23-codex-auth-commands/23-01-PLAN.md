---
phase: 23-codex-auth-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/auth/types.ts
  - src/auth/types.test.ts
  - src/auth/token-store.ts
  - src/auth/token-store.test.ts
  - src/auth/pkce-login.ts
  - src/auth/pkce-login.test.ts
  - src/auth/resolve.ts
  - src/auth/resolve.test.ts
  - src/auth/index.ts
  - src/providers/factory.ts
  - src/providers/factory.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "StoredCredential supports refreshToken and expiresAt for OAuth token lifecycle"
    - "PKCE login function performs browser-based OAuth with localhost callback and stores tokens via TokenStore"
    - "resolveAuth proactively refreshes subscription tokens within 5 minutes of expiry"
    - "Provider factory enforces concurrency=1 when authMethod is subscription"
  artifacts:
    - path: "src/auth/pkce-login.ts"
      provides: "PKCE browser OAuth flow with localhost callback server"
      exports: ["pkceLogin"]
    - path: "src/auth/types.ts"
      provides: "Extended StoredCredential with refreshToken field"
      contains: "refreshToken"
    - path: "src/auth/resolve.ts"
      provides: "Proactive token refresh for subscription auth"
      contains: "refreshIfNeeded"
    - path: "src/providers/factory.ts"
      provides: "Subscription concurrency=1 enforcement"
      contains: "subscription"
  key_links:
    - from: "src/auth/pkce-login.ts"
      to: "src/auth/token-store.ts"
      via: "TokenStore.write() after token exchange"
      pattern: "store\\.write"
    - from: "src/auth/resolve.ts"
      to: "src/auth/token-store.ts"
      via: "store.write() to persist refreshed credentials"
      pattern: "store\\.write"
    - from: "src/providers/factory.ts"
      to: "config.authMethod"
      via: "concurrency override guard"
      pattern: "authMethod.*subscription"
---

<objective>
Implement the PKCE OAuth flow plumbing, proactive token refresh, and subscription concurrency guard.

Purpose: Provides the core auth infrastructure that the CLI commands (Plan 02) will consume. Without this, `auth login` has no flow to execute and `resolveAuth` cannot refresh expiring tokens.
Output: `pkce-login.ts` with browser OAuth, extended `StoredCredential` type, refresh logic in `resolveAuth`, concurrency guard in `factory.ts`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-codex-auth-commands/23-RESEARCH.md
@.planning/phases/21-auth-infrastructure/21-01-SUMMARY.md
@.planning/phases/21-auth-infrastructure/21-02-SUMMARY.md
@src/auth/types.ts
@src/auth/token-store.ts
@src/auth/resolve.ts
@src/auth/index.ts
@src/providers/factory.ts
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StoredCredential, install deps, and implement PKCE login flow</name>
  <files>
    src/auth/types.ts
    src/auth/types.test.ts
    src/auth/token-store.ts
    src/auth/token-store.test.ts
    src/auth/pkce-login.ts
    src/auth/pkce-login.test.ts
    src/auth/index.ts
    package.json
  </files>
  <action>
**Step 1: Install dependencies.**
Run `npm install openid-client@^6 open@^10` to add PKCE and browser-launch libraries.

**Step 2: Extend StoredCredential in `src/auth/types.ts`.**
Add optional `refreshToken?: string` field to the `StoredCredential` interface. The existing `token` field holds the access token, `expiresAt` remains optional string (ISO 8601), and `refreshToken` holds the OAuth refresh token. Do NOT change any existing field semantics. Update the existing test file (`types.test.ts`) to verify the new field is accepted.

**Step 3: Update `isValidCredential` in `src/auth/token-store.ts`.**
Add validation for the new `refreshToken` field: if present, must be a non-empty string. Keep it optional — existing credentials without `refreshToken` remain valid.

**Step 4: Implement `src/auth/pkce-login.ts`.**

Export a single async function:
```typescript
export async function pkceLogin(provider: string, store: TokenStore): Promise<StoredCredential>
```

The function must:

a) **Detect headless environment.** If `!process.stdout.isTTY`, print the authorization URL via `@clack/prompts` `log.info()` and continue waiting (do NOT fail — user can copy the URL manually).

b) **Check for existing valid tokens.** Read from `store.read()`. If valid tokens exist for the same provider and `expiresAt` is in the future, prompt with `@clack/prompts` `confirm()`: "You already have valid tokens for {provider}. Re-authenticate?". If user declines, return the existing credential. If no TTY, skip confirmation and overwrite silently.

c) **Generate PKCE code verifier and challenge.** Use `openid-client` v6 API:
   - Use `randomPKCECodeVerifier()` and `calculatePKCECodeChallenge(verifier)` from `openid-client`.

d) **Start a temporary localhost HTTP server** on a random port using `node:http`:
   - `server.listen(0)` to get a random available port.
   - Register a handler for `GET /auth/callback` that extracts `code` from query params.
   - On successful callback, respond with a minimal HTML success page: `<h1>Authentication successful</h1><p>You can close this tab.</p>`.
   - On error/missing code, respond with an error page.

e) **Build the authorization URL.** OpenAI Codex OAuth parameters (from research):
   - Authorization endpoint: `https://auth.openai.com/oauth/authorize`
   - Token endpoint: `https://auth.openai.com/oauth/token`
   - Client ID: `app_EMoamEEZ73f0CkXaXp7hrann`
   - Redirect URI: `http://localhost:{port}/auth/callback`
   - Scope: `openid offline_access`
   - Response type: `code`
   - Code challenge method: `S256`
   - Audience: `https://api.openai.com/v1`
   Try `openid-client` discovery at `https://auth.openai.com/.well-known/openid-configuration` first, wrapped in try/catch. If discovery fails, construct the authorization URL manually using the hard-coded endpoints above.

f) **Open the browser.** Use `open` package (dynamic import: `const { default: openUrl } = await import('open')`). If headless (no TTY), skip `open()` and only print URL.

g) **Show spinner.** Use `@clack/prompts` `spinner()` with message "Waiting for authentication..." while waiting for the callback.

h) **Wait for callback with 120-second timeout.** Use a Promise that resolves when the HTTP handler receives the code, or rejects after 120 seconds. On timeout, close the server and throw an `AuthError` with code `AUTH_TIMEOUT` and fix text suggesting the user try again.

i) **Exchange code for tokens.** Use `openid-client`'s `authorizationCodeGrant()` or manual `fetch` to the token endpoint with:
   - `grant_type: authorization_code`
   - `code: {received_code}`
   - `redirect_uri: http://localhost:{port}/auth/callback`
   - `client_id: app_EMoamEEZ73f0CkXaXp7hrann`
   - `code_verifier: {verifier}`
   If `openid-client` discovery worked, use the client's built-in method. Otherwise, do a direct `fetch` POST.

j) **Persist tokens.** Build a `StoredCredential`:
   - `provider`: the provider argument
   - `token`: `access_token` from response
   - `refreshToken`: `refresh_token` from response (if present; `offline_access` scope should provide it)
   - `expiresAt`: compute from `expires_in` field: `new Date(Date.now() + expires_in * 1000).toISOString()`
   Write via `store.write(credential)`.

k) **Clean up.** Close the HTTP server. Stop the spinner with a success message.

l) **Return** the stored credential.

**Step 5: Add barrel export in `src/auth/index.ts`.**
Add `export { pkceLogin } from './pkce-login.js';`.

**Step 6: Write tests in `src/auth/pkce-login.test.ts`.**
Test with mocked `openid-client`, mocked `open`, and mocked HTTP server behavior:
- Test that `pkceLogin` starts server on random port and constructs correct auth URL.
- Test that successful callback extracts code and exchanges for tokens.
- Test that tokens are written to store after exchange.
- Test timeout scenario (server never receives callback).
- Test headless fallback (no TTY — URL printed, no browser opened).
- Test re-auth confirmation prompt when valid tokens exist.
- Mock `openid-client` at module level using `vi.mock()`. Mock the `open` package. Use a real (or mocked) `node:http` server for callback simulation.

**Important implementation notes:**
- Use dynamic `import('open')` to keep it tree-shakeable.
- Do NOT log tokens at info level — only log at debug level that authentication succeeded.
- The function should be pure in its store interaction — no global state.
- Handle the case where `refresh_token` is not returned gracefully (set `refreshToken` to `undefined`).
  </action>
  <verify>
Run `npm run typecheck` to confirm no type errors.
Run `npx vitest run src/auth/pkce-login.test.ts` to confirm PKCE tests pass.
Run `npx vitest run src/auth/types.test.ts` to confirm StoredCredential extension tests pass.
Run `npx vitest run src/auth/token-store.test.ts` to confirm TokenStore validation still passes.
  </verify>
  <done>
`pkceLogin()` function exists and is exported from `src/auth/index.ts`. `StoredCredential` includes optional `refreshToken` field. `openid-client` and `open` are installed. All auth tests pass including PKCE flow tests with mocked browser/server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add proactive token refresh in resolveAuth and subscription concurrency guard in factory</name>
  <files>
    src/auth/resolve.ts
    src/auth/resolve.test.ts
    src/providers/factory.ts
    src/providers/factory.test.ts
  </files>
  <action>
**Step 1: Implement `refreshIfNeeded` helper in `src/auth/resolve.ts`.**

Add an internal (non-exported) async function:
```typescript
async function refreshIfNeeded(
  credential: StoredCredential,
  store: TokenStore,
): Promise<StoredCredential>
```

Logic:
- If `credential.expiresAt` is not set, return credential as-is (no expiry info to check).
- If `credential.refreshToken` is not set, return credential as-is (cannot refresh without refresh token).
- Parse `credential.expiresAt` as a Date. If more than 5 minutes from now, return credential as-is.
- If within 5 minutes of expiry (or already expired):
  a) Attempt token refresh using `openid-client` `refreshTokenGrant()` or direct `fetch` POST to `https://auth.openai.com/oauth/token` with:
     - `grant_type: refresh_token`
     - `refresh_token: credential.refreshToken`
     - `client_id: app_EMoamEEZ73f0CkXaXp7hrann`
  b) On success: build new `StoredCredential` with updated `token`, `refreshToken` (if rotated), `expiresAt`. Persist via `store.write()`. Log at debug level: `[auth] Token refreshed for {provider}`.
  c) On failure: log warning `[auth] Token refresh failed, trying current token`. Return the original credential unchanged (try current token first strategy per discretion).

**Step 2: Wire `refreshIfNeeded` into the subscription credential path of `resolveAuth()`.**

In the existing `if (config.authMethod === 'subscription')` block in `resolveAuth()`, after reading the credential from the store and before returning, call:
```typescript
const refreshed = await refreshIfNeeded(credential, tokenStore);
return { apiKey: refreshed.token, source: 'credential-store' };
```

This replaces the current direct return of `credential.token`.

**Step 3: Add subscription concurrency guard to `src/providers/factory.ts`.**

In `createProvider()`, after `validateProviderConfig(config)` and before the provider switch, add:

```typescript
// CDX-05: Subscription mode enforces concurrency=1 to respect rate limits
if (config.authMethod === 'subscription') {
  logger.info('[factory] Subscription auth: enforcing concurrency=1');
}
```

Then, when resolving concurrency for both the custom provider path and the preset provider path, override:
```typescript
const concurrency = config.authMethod === 'subscription'
  ? 1
  : (config.analysis.concurrency ?? preset.defaultConcurrency);
```

Apply this pattern in BOTH the custom provider block and the preset provider block. The subscription guard takes absolute precedence regardless of config value.

**Step 4: Update tests.**

In `src/auth/resolve.test.ts`:
- Add test: subscription credential within 5 minutes of expiry triggers refresh attempt.
- Add test: subscription credential more than 5 minutes from expiry returns without refresh.
- Add test: subscription credential with no `refreshToken` returns without refresh attempt.
- Add test: refresh failure falls back to current token with warning log.
- Mock the token refresh HTTP call (mock `fetch` or `openid-client`).

In `src/providers/factory.test.ts`:
- Add test: `createProvider` with `authMethod: 'subscription'` uses concurrency=1 regardless of `analysis.concurrency` config value.
- Add test: `createProvider` with `authMethod: 'api-key'` respects configured concurrency.

**Important notes:**
- The 5-minute buffer is a fixed constant: `const REFRESH_BUFFER_MS = 5 * 60 * 1000;`
- Import `logger` for debug-level refresh logging.
- Do NOT import from `pkce-login.ts` — the refresh uses a direct token endpoint call, not the full PKCE flow. This avoids circular dependencies.
- For the token refresh fetch, use native `fetch()` (available in Node 18+).
  </action>
  <verify>
Run `npm run typecheck` to confirm no type errors.
Run `npx vitest run src/auth/resolve.test.ts` to confirm all resolve tests pass including new refresh tests.
Run `npx vitest run src/providers/factory.test.ts` to confirm factory tests pass including concurrency guard.
Run `npx vitest run` to confirm full test suite passes.
  </verify>
  <done>
`resolveAuth()` proactively refreshes subscription tokens within 5 minutes of expiry. Token refresh failure falls back to trying current token. `createProvider()` enforces `concurrency=1` when `authMethod: subscription`. All existing and new tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors.
2. `npx vitest run src/auth/` passes all auth module tests.
3. `npx vitest run src/providers/factory.test.ts` passes with subscription concurrency guard.
4. `npx vitest run` full suite passes — no regressions.
5. `StoredCredential` type includes `refreshToken` optional field.
6. `pkceLogin` is exported from `src/auth/index.ts`.
7. `openid-client` and `open` are in `package.json` dependencies.
</verification>

<success_criteria>
- PKCE login flow function exists and handles browser OAuth with localhost callback, timeout, headless fallback, and re-auth confirmation.
- Proactive token refresh happens transparently inside resolveAuth when subscription tokens are near expiry.
- Provider factory enforces concurrency=1 for subscription auth regardless of config.
- All tests pass, no type errors.
</success_criteria>

<output>
After completion, create `.planning/phases/23-codex-auth-commands/23-01-SUMMARY.md`
</output>
