---
phase: 05-ux-responsiveness
plan: 02
type: execute
wave: 2
depends_on: ['05-01']
files_modified:
  - src/cli/index.ts
  - src/cli/generate.ts
  - src/ui/components.ts
  - src/ui/ci-renderer.ts
autonomous: true

must_haves:
  truths:
    - 'Users can opt in to see streaming token output via a --stream CLI flag'
    - 'Before AI rounds start, the terminal shows a file coverage line with analyzed and ignored counts'
    - 'When rounds 5 and 6 both run (not cached), the completion summary shows time saved by parallelism'
    - 'CI renderer logs file coverage and parallel savings in structured format'
  artifacts:
    - path: 'src/cli/index.ts'
      provides: '--stream flag on generate command'
      contains: '--stream'
    - path: 'src/cli/generate.ts'
      provides: 'File coverage emission, parallel savings computation, stream flag handling'
      contains: 'fileCoverage'
    - path: 'src/ui/components.ts'
      provides: 'renderFileCoverage component and parallel savings line'
      contains: 'renderFileCoverage'
    - path: 'src/ui/ci-renderer.ts'
      provides: 'CI-friendly file coverage and parallel savings logging'
      contains: 'file-coverage'
  key_links:
    - from: 'src/cli/generate.ts'
      to: 'src/ui/components.ts'
      via: 'generate calls renderFileCoverage with PackedContext.metadata'
      pattern: 'renderFileCoverage.*metadata'
    - from: 'src/cli/generate.ts'
      to: 'src/ui/renderer.ts'
      via: 'generate calls renderer.append for file coverage and renderer.onComplete for savings'
      pattern: 'renderer.*fileCoverage|parallelSaved'
---

<objective>
Add the --stream CLI flag, file coverage indicator, and parallel round savings display to complete the Phase 5 UX responsiveness features.

Purpose: Give users scope visibility (file coverage before rounds), explicit parallelism feedback (time saved), and opt-in streaming token visibility. These three features round out the interactive experience built on the streaming foundation from Plan 05-01.

Output: `--stream` flag registered and wired. File coverage line appears before AI rounds. Completion summary includes parallel savings when applicable.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ux-responsiveness/05-RESEARCH.md
@.planning/phases/05-ux-responsiveness/05-01-SUMMARY.md

@src/cli/index.ts
@src/cli/generate.ts
@src/ui/components.ts
@src/ui/renderer.ts
@src/ui/ci-renderer.ts
@src/ui/types.ts
@src/ui/formatters.ts
@src/context/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --stream flag and file coverage indicator</name>
  <files>
    src/cli/index.ts
    src/cli/generate.ts
    src/ui/components.ts
    src/ui/types.ts
  </files>
  <action>
Add the `--stream` CLI flag for opt-in streaming visibility and a file coverage indicator that shows file scope before AI rounds begin.

**src/cli/index.ts** — Register `--stream` flag:

- Add `.option('--stream', 'Show streaming token output during AI rounds')` to the `generate` command, alongside existing `--verbose` and `--no-cache` flags.
- Do NOT add `--stream` to the default action (top-level program options) — it only applies to `generate`.

**src/cli/generate.ts** — Add `stream` to GenerateOptions and wire both features:

1. Add `stream?: boolean` to the `GenerateOptions` interface.

2. **File coverage indicator:** After `packedContext` is assigned (after the `packFiles()` call inside the static-analysis step), and after `displayState.phase = 'ai-rounds'`, emit a file coverage line:
   - Import `renderFileCoverage` from `../ui/components.js`.
   - Call renderer to append the file coverage line. Since `TerminalRenderer` doesn't expose `append` publicly, use a new renderer event. Add `onFileCoverage?(state: DisplayState): void` to the `Renderer` interface in types.ts, then call `renderer.onFileCoverage(displayState)` after setting the phase to 'ai-rounds'.
   - Store file coverage data on `DisplayState`. Add `fileCoverage?: { analyzing: number; ignored: number; total: number }` to `DisplayState` in types.ts.
   - Populate it from `packedContext.metadata`: `analyzing = metadata.fullFiles + metadata.signatureFiles`, `ignored = metadata.skippedFiles`, `total = metadata.totalFiles`.

3. **Stream flag handling:** When `options.stream` is true, the `onToken` callbacks created in 05-01 should additionally write streaming indicators. The simplest approach per research: when `--stream` is active, the live progress line already shows the token counter (from 05-01). The opt-in streaming behavior adds a visual indicator that tokens are being received — use a streaming activity indicator in the progress line. Implementation:
   - Add `streamVisible?: boolean` to `DisplayState`.
   - Set `displayState.streamVisible = options.stream === true` early in runGenerate.
   - In `renderRoundBlock` (components.ts), when the round is running and `streamVisible` would be true, show a second line below the progress line with a streaming indicator: `"  streaming..."` in dim text. Pass `streamVisible` into `renderRoundBlock` as a parameter.
   - When `--stream` is not set, behavior is exactly as 05-01 established — compact progress line only.

**src/ui/types.ts** — Extend interfaces:

- Add `fileCoverage?: { analyzing: number; ignored: number; total: number }` to `DisplayState`.
- Add `streamVisible?: boolean` to `DisplayState`.
- Add `onFileCoverage?(state: DisplayState): void` to the `Renderer` interface.

**src/ui/components.ts** — Add `renderFileCoverage` component:

- Create an exported function `renderFileCoverage(coverage: { analyzing: number; ignored: number; total: number }): string` that returns:

  ```
  ◆ 142 files · 104 analyzing · 10 ignored
  ```

  Use `pc.dim('◆')` for the bullet, `pc.cyan(String(analyzing))` for the analyzing count, `pc.dim(String(ignored))` for the ignored count. Separate with `pc.dim(' · ')`.

- Note on "cached" in the locked decision example: The locked decision shows "28 cached" but file-level caching doesn't exist in the data model. Omit "cached" from the file coverage line. The `signatureFiles` (partial content) are included in the "analyzing" count alongside `fullFiles` since both are sent to the LLM. This is a reasonable interpretation per research Open Question #1.

- Update `renderRoundBlock` signature to accept `streamVisible?: boolean` as an additional parameter. In the running state (non-retrying), if `streamVisible` is true, add a second dim line below the progress line: `pc.dim('  streaming...')`.
  </action>
  <verify>
  Run `npx tsc --noEmit` — no new type errors.
  Run `npm test` — all tests pass.
  Verify `handover generate --help` shows `--stream` flag in help output.
  </verify>
  <done>
  The `--stream` flag is registered on the generate command and wired through GenerateOptions. A file coverage line ("142 files · 104 analyzing · 10 ignored") appears before AI rounds begin. When `--stream` is active, a "streaming..." indicator appears below the running round's progress line. The Renderer interface has a new `onFileCoverage` event.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Parallel round savings and CI renderer updates</name>
  <files>
    src/cli/generate.ts
    src/ui/components.ts
    src/ui/ci-renderer.ts
    src/ui/renderer.ts
  </files>
  <action>
Compute and display the time saved by parallel execution of rounds 5 and 6, and update the CI renderer to support all new display features.

**src/ui/components.ts** — Add parallel savings computation:

- Create an exported function `computeParallelSavings(rounds: Map<number, RoundDisplayState>): number | null`:
  - Get `r5 = rounds.get(5)` and `r6 = rounds.get(6)`.
  - If either is undefined, or either has `status === 'cached'`, or either has `status !== 'done'`, return `null`.
  - Compute `parallelWallTime = Math.max(r5.elapsedMs, r6.elapsedMs)`.
  - Compute `sequentialTime = r5.elapsedMs + r6.elapsedMs`.
  - Compute `savedMs = sequentialTime - parallelWallTime`.
  - Return `savedMs > 2000 ? savedMs : null` (only report if > 2 seconds saved).

- Create an exported function `renderParallelSavings(savedMs: number): string`:
  - Format: `pc.dim('  Parallel execution saved ~') + formatDuration(savedMs)`.
  - Use `formatDuration` from formatters.ts.

**src/cli/generate.ts** — Wire parallel savings into completion:

- Before the final `renderer.onComplete(displayState)` call (around line 830), compute parallel savings:
  ```typescript
  const parallelSavedMs = computeParallelSavings(displayState.rounds);
  ```
- Store on displayState. Add `parallelSavedMs?: number` to `DisplayState` in types.ts (another small addition).
- If `parallelSavedMs !== null`, set `displayState.parallelSavedMs = parallelSavedMs`.

**src/ui/components.ts** — Update `renderCompletionSummary`:

- After the existing completion line, if `state.parallelSavedMs` is defined and > 0, append a second line via `renderParallelSavings(state.parallelSavedMs)`.
- Return `[completionLine, savingsLine].filter(Boolean)` so it's only included when relevant.

**src/ui/renderer.ts** — Implement `onFileCoverage`:

- Add the `onFileCoverage(state: DisplayState): void` method:
  - If `state.fileCoverage`, call `this.append([renderFileCoverage(state.fileCoverage)])`.
  - Import `renderFileCoverage` from components.

**src/ui/ci-renderer.ts** — Add CI support for new features:

- Implement `onFileCoverage(state: DisplayState): void`:
  - Log: `${this.timestamp()} [files] ${state.fileCoverage.total} files: ${state.fileCoverage.analyzing} analyzing, ${state.fileCoverage.ignored} ignored`.
- In `onComplete`, after the existing completion log, check `state.parallelSavedMs`:
  - If defined and > 0, log: `${this.timestamp()} [perf] Parallel execution saved ~${Math.round(state.parallelSavedMs / 1000)}s`.

**src/ui/types.ts** — Final additions:

- Add `parallelSavedMs?: number` to `DisplayState`.

**Important:** Rounds 5 and 6 already execute in parallel via the DAGOrchestrator (both declare `deps: ['ai-round-2']`). No changes to round dependency declarations or the orchestrator are needed. This task is purely display logic — computing and surfacing the time savings.
</action>
<verify>
Run `npx tsc --noEmit` — no new type errors.
Run `npm test` — all tests pass.
Review that `computeParallelSavings` correctly handles: both cached (returns null), one cached (returns null), both done with < 2s savings (returns null), both done with significant savings (returns the milliseconds saved).
</verify>
<done>
When rounds 5 and 6 both execute (not cached), the completion summary includes "Parallel execution saved ~12s". CI renderer logs file coverage and parallel savings in structured format. All four Phase 5 success criteria are met: live token counter (05-01), streaming output (--stream flag), parallel savings visibility, and file coverage indicator.
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (pre-existing runner.ts error acceptable)
2. `npm test` passes — all existing tests remain green
3. `handover generate --help` shows `--stream` flag
4. File coverage line is rendered before AI rounds in both TTY and CI modes
5. Parallel savings only appears when both rounds 5 and 6 ran (not cached) and saved > 2 seconds
6. CI renderer logs structured output for file coverage and parallel savings
7. Renderer interface has `onFileCoverage` method implemented by both TerminalRenderer and CIRenderer
</verification>

<success_criteria>

- File coverage line appears before AI rounds showing analyzed and ignored file counts (UX-04)
- `--stream` flag enables streaming visibility during rounds (UX-02)
- Completion summary includes parallel execution savings when applicable (UX-03)
- CI renderer supports all new display events in structured log format
  </success_criteria>

<output>
After completion, create `.planning/phases/05-ux-responsiveness/05-02-SUMMARY.md`
</output>
