---
phase: 11-ai-round-tests-and-coverage-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ai-rounds/runner.test.ts
  - src/ai-rounds/validator.test.ts
  - src/context/compressor.test.ts
  - src/utils/rate-limiter.test.ts
autonomous: true

must_haves:
  truths:
    - "executeRound() happy path returns status 'success' with tool_use mock response data"
    - "executeRound() provider throw returns status 'degraded' with fallback data and validation zeros"
    - "executeRound() high drop rate triggers single retry then returns status 'retried'"
    - "executeRound() quality failure triggers single retry then returns status 'retried'"
    - 'executeRound() degraded result is idempotent — same input always produces same fallback structure'
    - 'validateFileClaims() drops claims for non-existent file paths'
    - 'validateFileClaims() keeps claims for paths present in analysis.fileTree.directoryTree'
    - 'validateRoundClaims() computes correct dropRate from combined file and import claims'
    - 'compressRoundOutput() extracts modules, findings, relationships, openQuestions from round output'
    - 'compressRoundOutput() enforces token budget by truncating openQuestions first, then findings'
    - 'retryWithBackoff() retries on 429 status and succeeds on second attempt using vi.useFakeTimers()'
    - 'retryWithBackoff() throws ProviderError when all retries exhausted'
  artifacts:
    - path: 'src/ai-rounds/runner.test.ts'
      provides: 'executeRound unit tests — happy, degraded, retry paths'
    - path: 'src/ai-rounds/validator.test.ts'
      provides: 'validateFileClaims, validateImportClaims, validateRoundClaims unit tests'
    - path: 'src/context/compressor.test.ts'
      provides: 'compressRoundOutput unit tests — field extraction and token budget enforcement'
    - path: 'src/utils/rate-limiter.test.ts'
      provides: 'retryWithBackoff unit tests with vi.useFakeTimers()'
  key_links:
    - from: 'src/ai-rounds/runner.test.ts'
      to: 'src/providers/__mocks__/index.ts'
      via: 'createMockProvider() factory'
      pattern: 'createMockProvider'
    - from: 'src/ai-rounds/runner.test.ts'
      to: 'src/context/tracker.ts'
      via: 'TokenUsageTracker real instance'
      pattern: 'new TokenUsageTracker'
    - from: 'src/utils/rate-limiter.test.ts'
      to: 'src/utils/rate-limiter.ts'
      via: 'vi.useFakeTimers + vi.advanceTimersByTimeAsync'
      pattern: 'advanceTimersByTimeAsync'
---

<objective>
Write unit tests for the AI round runner (executeRound), claim validators (validateFileClaims, validateImportClaims, validateRoundClaims), inter-round compressor (compressRoundOutput), and the retry-with-backoff utility (retryWithBackoff).

Purpose: Cover the four most critical AI-round modules with tests that exercise happy paths, error paths, retry behavior, and boundary conditions — satisfying TEST-12, TEST-13, and TEST-14 requirements.
Output: Four colocated test files with passing tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ai-round-tests-and-coverage-enforcement/11-RESEARCH.md

@src/ai-rounds/runner.ts
@src/ai-rounds/validator.ts
@src/ai-rounds/quality.ts
@src/ai-rounds/types.ts
@src/context/compressor.ts
@src/context/types.ts
@src/utils/rate-limiter.ts
@src/utils/errors.ts
@src/providers/**mocks**/index.ts
@src/providers/base.ts
@src/context/tracker.ts
@src/context/packer.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write executeRound and validator tests</name>
  <files>
    src/ai-rounds/runner.test.ts
    src/ai-rounds/validator.test.ts
  </files>
  <action>
Create `src/ai-rounds/runner.test.ts` with the following test cases for `executeRound()`:

**Happy path (tool_use response):**

- Create a fresh `createMockProvider()` per test. Cast `provider.complete as ReturnType<typeof vi.fn>` then call `.mockResolvedValueOnce()` with a shape-accurate response: `{ data: { sections: [{title: 'Overview', content: 'Project desc.'}], signatures: ['function main(): void'] }, usage: { inputTokens: 100, outputTokens: 50, cacheReadTokens: 0, cacheCreationTokens: 0 }, model: 'mock', duration: 0 }`.
- Build the `ExecuteRoundOptions` object: `roundNumber: 1`, real `TokenUsageTracker` instance (import from `../context/tracker.js`), `buildPrompt: () => ({ systemPrompt: 'sys', userPrompt: 'user', model: 'mock', maxTokens: 1000 })`, `validate: () => ({ validated: 1, corrected: 0, total: 1, dropRate: 0 })`, `buildFallback: () => ({})`, `estimateTokensFn: (t) => t.length`, `schema: z.any()` (import z from zod).
- Assert: `result.status === 'success'`, `result.data` matches the mock data, `result.validation.dropRate === 0`, `result.quality` is defined, `result.context.roundNumber === 1`.

**Degraded path (provider throws):**

- Mock `provider.complete` to reject with `new Error('API unavailable')`.
- Assert: `result.status === 'degraded'`, `result.validation` equals `{ validated: 0, corrected: 0, total: 0, dropRate: 0 }`, `result.quality.isAcceptable === false`, `result.data` matches the fallback object from `buildFallback`.
- Assert idempotency: call again with same options, assert result structure is identical.

**Retry on high drop rate (>0.3):**

- First call: mock `provider.complete` resolves with valid data. Set `validate` to return `{ dropRate: 0.5, ... }` on first call and `{ dropRate: 0, ... }` on second call (use a counter variable).
- Mock `provider.complete` with `.mockResolvedValue()` (both calls succeed).
- Assert: `result.status === 'retried'`, `provider.complete` called twice (via `toHaveBeenCalledTimes(2)`).

**Retry on quality failure:**

- Mock provider resolves with data that would fail the `checkRoundQuality` check (e.g., `{ data: { note: 'short' } }` — no file paths, short text). The validate function returns `{ dropRate: 0, ... }` (passes validation). Quality check fails on first call. Chain two `mockResolvedValueOnce` — first with minimal data (quality fails), second with richer data containing file paths and longer text that passes quality.
- Assert: `result.status === 'retried'`.

**Error message is actionable (degraded path):**

- Mock provider rejects. Spy on `logger.warn` and assert the warning message contains the round number and the error text.

Use `afterEach(() => { vi.restoreAllMocks(); })` to clean up between tests. Each test creates its own fresh mock provider (per locked decision: no shared mutable mock state).

Create `src/ai-rounds/validator.test.ts` with tests for:

**validateFileClaims():**

- Build a minimal `StaticAnalysisResult` fixture using the `mkAnalysis(filePaths: string[])` factory pattern from the research (populate all required fields with zeros/empty arrays; only `fileTree.directoryTree` matters). Use `as StaticAnalysisResult` type cast.
- Test: all paths valid — `validateFileClaims(['src/foo.ts', 'src/bar.ts'], mkAnalysis(['src/foo.ts', 'src/bar.ts']))` → `valid.length === 2, dropped.length === 0`.
- Test: one path missing — `validateFileClaims(['src/foo.ts', 'src/missing.ts'], mkAnalysis(['src/foo.ts']))` → `valid === ['src/foo.ts'], dropped === ['src/missing.ts']`.
- Test: empty claimed paths — returns empty valid and empty dropped.
- Test: drop rate calculation — `2/3 dropped = 67% drop rate > 0.3`.

**validateImportClaims():**

- Build fixture with `ast.files` containing import data.
- Test: valid import claim → kept.
- Test: non-existent import → dropped.

**validateRoundClaims():**

- Test: round output with file paths and import claims returns correct totals and dropRate.
- Test: round output with no extractable claims → `{ validated: 0, corrected: 0, total: 0, dropRate: 0 }`.
  </action>
  <verify>
  Run `npx vitest run src/ai-rounds/runner.test.ts src/ai-rounds/validator.test.ts` — all tests pass with zero failures.
  Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
  executeRound() tests cover happy path, degraded, retry-on-dropRate, and retry-on-quality — all pass. validateFileClaims(), validateImportClaims(), and validateRoundClaims() tests pass with fixture StaticAnalysisResult inputs.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Write compressRoundOutput and retryWithBackoff tests</name>
  <files>
    src/context/compressor.test.ts
    src/utils/rate-limiter.test.ts
  </files>
  <action>
Create `src/context/compressor.test.ts` with tests for `compressRoundOutput()`:

Use `const charTokens = (text: string): number => text.length;` as the deterministic token estimator (same pattern as packer.test.ts).

**Field extraction tests:**

- Test: extracts `modules` from array of `{ name: string }` objects → `ctx.modules` contains the name strings.
- Test: extracts `modules` from array of plain strings → `ctx.modules` contains those strings.
- Test: extracts `findings` from `output.findings` array.
- Test: extracts `findings` from `output.keyFindings` (alias key).
- Test: extracts `relationships` from array of `{ from, to, type }` objects → formatted strings like `"a.ts -> b.ts (import)"`.
- Test: extracts `openQuestions` from `output.openQuestions` array.
- Test: `roundNumber` in returned context matches input.
- Test: `tokenCount` is > 0 for non-empty output.
- Test: empty output `{}` → all arrays empty, tokenCount reflects just the header line.

**Token budget enforcement tests:**

- Test: all fields fit within budget → no truncation (openQuestions preserved).
- Test: tight budget → openQuestions trimmed first (check `ctx.openQuestions.length < original`).
- Test: very tight budget → findings trimmed to 1 (min-1 rule when findings existed originally).
- Test: extremely tight budget → relationships and modules also trimmed.

Create `src/utils/rate-limiter.test.ts` with tests for `retryWithBackoff()`:

**CRITICAL: Use `vi.useFakeTimers()` in `beforeEach` and `vi.useRealTimers()` in `afterEach`.** Use `vi.advanceTimersByTimeAsync()` (the ASYNC variant — not the sync one).

**Tests:**

- Test: function succeeds on first try → returns result, `fn` called once.
- Test: function fails with status 429, succeeds on retry → `fn` called twice, returns 'ok'. After starting the promise, call `await vi.advanceTimersByTimeAsync(45_000)` to advance past the max jitter window (baseDelayMs \* 1.5 = 45000ms for attempt 0). Then await the promise.
- Test: function fails with non-retryable error (no status field) → throws immediately, `fn` called once.
- Test: all retries exhausted → throws `ProviderError`. Advance timers multiple times (45_000 per retry) to progress through all attempts.
- Test: timeout scenario — function always throws 429 and maxRetries is 0 → throws on first failure.
- Test: `onRetry` callback is called with correct attempt number and delay.

**Pattern for async timer advancement:**

```typescript
const promise = retryWithBackoff(fn, { maxRetries: 1, baseDelayMs: 30_000 });
await vi.advanceTimersByTimeAsync(45_000);
const result = await promise;
```

Also add basic tests for `RateLimiter` class:

- Test: `acquire()` resolves immediately when under limit.
- Test: `withLimit()` executes function and returns result.
- Test: `acquire()` queues when at capacity, resolves after `release()`.
  </action>
  <verify>
  Run `npx vitest run src/context/compressor.test.ts src/utils/rate-limiter.test.ts` — all tests pass with zero failures.
  Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
  compressRoundOutput() tests verify field extraction from all key paths (modules, findings, relationships, openQuestions) and progressive token budget truncation. retryWithBackoff() tests verify successful retry, non-retryable fast-fail, all-retries-exhausted, and onRetry callback — using vi.useFakeTimers() + vi.advanceTimersByTimeAsync().
  </done>
  </task>

</tasks>

<verification>
1. `npx vitest run src/ai-rounds/runner.test.ts src/ai-rounds/validator.test.ts src/context/compressor.test.ts src/utils/rate-limiter.test.ts` — all tests pass.
2. `npx tsc --noEmit` — no type errors in the project.
3. Each test file creates fresh mocks per test (no shared mutable state between test cases).
4. `vi.useFakeTimers()` appears ONLY in rate-limiter.test.ts (not in runner.test.ts — the round-level retry does not use timers).
5. No real LLM API calls made in any test.
</verification>

<success_criteria>

- All executeRound test paths pass: happy, degraded, retry-on-dropRate, retry-on-quality
- All validateFileClaims/validateImportClaims/validateRoundClaims tests pass with fixture inputs
- All compressRoundOutput tests pass: field extraction + token budget enforcement
- All retryWithBackoff tests pass using vi.useFakeTimers + vi.advanceTimersByTimeAsync
- `npx tsc --noEmit` clean
  </success_criteria>

<output>
After completion, create `.planning/phases/11-ai-round-tests-and-coverage-enforcement/11-01-SUMMARY.md`
</output>
