---
phase: 07-terminal-ux
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/cli/generate.ts
  - src/utils/logger.ts
autonomous: true

must_haves:
  truths:
    - "Running `handover generate` displays a single-line Vite-style startup banner with project name, provider, model, file count, and language"
    - "Static analysis phase shows 8 analyzer lines updating in-place with pending/running/done/failed symbols"
    - "AI analysis phase shows stacked round lines with spinner + elapsed time, updating simultaneously in-place"
    - "Completed rounds show token count and cost, plus running total below the active block"
    - "Document rendering appends each filename as it completes"
    - "Completion summary is a compact single line with doc count, tokens, cost, and duration"
    - "Non-TTY environments get structured log lines with timestamps instead of ANSI rendering"
    - "Errors show brief inline status during pipeline + full details at the end"
    - "Cost warning appears in yellow when total exceeds costWarningThreshold"
  artifacts:
    - path: "src/cli/generate.ts"
      provides: "Refactored generate command using TerminalRenderer/CIRenderer for all progress output"
      exports: ["runGenerate"]
    - path: "src/utils/logger.ts"
      provides: "Logger with optional suppress mode for renderer coexistence"
      exports: ["logger", "Logger"]
  key_links:
    - from: "src/cli/generate.ts"
      to: "src/ui/renderer.ts"
      via: "import { createRenderer } from '../ui/renderer.js'"
      pattern: "createRenderer"
    - from: "src/cli/generate.ts"
      to: "src/ui/types.ts"
      via: "import type { DisplayState } from '../ui/types.js'"
      pattern: "DisplayState"
    - from: "src/cli/generate.ts"
      to: "src/analyzers/coordinator.ts"
      via: "onProgress callback wired to renderer.onAnalyzerUpdate"
      pattern: "onProgress"
    - from: "src/cli/generate.ts"
      to: "src/ai-rounds/runner.ts"
      via: "progress callbacks wired to renderer.onRoundUpdate"
      pattern: "progress:"
---

<objective>
Wire the terminal renderer into generate.ts, replacing all logger/console.log calls with the renderer system, and add logger suppress mode for renderer coexistence.

Purpose: This is the integration plan that makes everything visible. Plans 07-01 (renderer) and 07-02 (events) built the components and hooks; this plan connects them so `handover generate` shows rich progress output matching the Vite/Turborepo aesthetic.

Output: Refactored generate.ts with full renderer integration, logger with suppress mode.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-terminal-ux/07-RESEARCH.md
@.planning/phases/07-terminal-ux/07-01-SUMMARY.md
@.planning/phases/07-terminal-ux/07-02-SUMMARY.md
@src/cli/generate.ts
@src/utils/logger.ts
@src/ui/types.ts
@src/ui/renderer.ts
@src/ui/ci-renderer.ts
@src/ui/components.ts
@src/ui/formatters.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add suppress mode to logger for renderer coexistence</name>
  <files>src/utils/logger.ts</files>
  <action>
The logger is a singleton that writes to `console.log`/`console.error`. During renderer-managed output, any stray `console.log` from logger or other code would corrupt the multi-line display (per pitfall #1 in research).

Add a `suppress` mode to the Logger class:
- Private field: `private suppressed = false;`
- Public method: `setSuppressed(enabled: boolean): void` — sets the flag.
- Modify ALL output methods (`info`, `log`, `warn`, `success`, `step`, `ai`, `blank`) to check `this.suppressed` at the top and return immediately if true.
- `error()` should NEVER be suppressed — errors must always output. Leave error() unchanged (it goes to stderr via `console.error`, which doesn't interfere with the renderer's stdout management).

This is a minimal change. The renderer will call `logger.setSuppressed(true)` before starting and `logger.setSuppressed(false)` after completing (in the finally/destroy block).

The `error()` method already uses `console.error` (stderr), which is separate from the renderer's stdout, so it won't corrupt the display.
  </action>
  <verify>`npx tsc --noEmit` — compiles. Verify `logger.setSuppressed` exists and all stdout methods early-return when suppressed.</verify>
  <done>Logger has a suppress mode. When suppressed, all stdout-based methods (info, log, warn, success, step, ai, blank) are no-ops. Error output (stderr) is never suppressed.</done>
</task>

<task type="auto">
  <name>Task 2: Wire renderer into generate.ts for full terminal UX</name>
  <files>src/cli/generate.ts</files>
  <action>
Refactor `runGenerate()` to use the renderer system for all progress output. This is a significant refactor of generate.ts but does NOT change the pipeline logic — only how progress is displayed.

**Step 1: Imports and setup**
Add imports at top:
```typescript
import { createRenderer } from '../ui/renderer.js';
import type { DisplayState, ErrorInfo } from '../ui/types.js';
import { ROUND_NAMES } from '../ai-rounds/types.js';
```

**Step 2: Create display state and renderer**
After config loading and before the static-only check, create the display state object and renderer:

```typescript
const renderer = createRenderer();

// Mutable display state — updated throughout the pipeline, renderer reads it
const displayState: DisplayState = {
  phase: 'startup',
  projectName: config.project.name ?? 'project',
  provider: config.provider,
  model: config.model ?? 'default',
  fileCount: 0, // updated after static analysis
  language: '', // detected after static analysis
  analyzers: new Map(),
  analyzerElapsedMs: 0,
  rounds: new Map(),
  totalTokens: 0,
  totalCost: 0,
  costWarningThreshold: config.costWarningThreshold ?? 1.0,
  elapsedMs: 0,
  renderedDocs: [],
  completionDocs: 0,
  errors: [],
};
```

**Step 3: Suppress logger during renderer-managed output**
After creating the renderer, call `logger.setSuppressed(true)` to prevent stray console.log calls from corrupting the display.

Wrap the entire pipeline in a try/finally that calls:
```typescript
finally {
  renderer.destroy();
  logger.setSuppressed(false);
}
```

**Step 4: Startup banner**
Replace the current header output (the `logger.info(pc.bold('handover')...)` and SEC-03 warning lines) with:
```typescript
renderer.onBanner(displayState);
```

The banner component already includes the provider/model info, serving as the SEC-03 cloud indicator.

**Step 5: Static analysis with progress**
Initialize the analyzer Map with all 8 analyzers as 'pending':
```typescript
const ANALYZER_NAMES = ['file-tree', 'dependencies', 'git-history', 'todos', 'env', 'ast', 'tests', 'docs'];
for (const name of ANALYZER_NAMES) {
  displayState.analyzers.set(name, 'pending');
}
displayState.phase = 'static-analysis';
```

Pass `onProgress` to `runStaticAnalysis`:
```typescript
const analyzerStart = Date.now();
const result = await runStaticAnalysis(rootDir, config, {
  onProgress: (analyzer, status) => {
    displayState.analyzers.set(analyzer, status === 'start' ? 'running' : status);
    displayState.analyzerElapsedMs = Date.now() - analyzerStart;
    renderer.onAnalyzerUpdate(displayState);
  },
});
```

After static analysis completes, update state and call `renderer.onAnalyzersDone(displayState)`:
```typescript
// Detect language from file extensions
const exts = result.fileTree.filesByExtension;
const topExt = Object.entries(exts).sort((a, b) => b[1] - a[1])[0];
displayState.language = topExt ? extToLanguage(topExt[0]) : 'Unknown';
displayState.fileCount = result.metadata.fileCount;
displayState.analyzerElapsedMs = Date.now() - analyzerStart;
renderer.onAnalyzersDone(displayState);
```

Add a small helper function `extToLanguage(ext: string): string` that maps common extensions to language names: `.ts`/`.tsx` -> `TypeScript`, `.js`/`.jsx` -> `JavaScript`, `.py` -> `Python`, `.rs` -> `Rust`, `.go` -> `Go`, `.java` -> `Java`, `.rb` -> `Ruby`, default -> capitalize the extension.

**Step 6: AI rounds with progress**
Change `displayState.phase = 'ai-rounds'`.

Pass the `model` parameter to the `TokenUsageTracker` constructor so cost estimation works:
```typescript
const tracker = new TokenUsageTracker(0.85, config.model ?? 'claude-opus-4-6');
```

For each `createRoundNStep` call, thread through `progress` callbacks and `roundName`/`affectedDocs`. Since the round step creators are factory functions that return `StepDefinition`, and the `ExecuteRoundOptions.progress` is inside the step's execute function, the progress callbacks need to be passed to each `createRoundNStep`.

The cleanest approach: create a shared `ProgressCallbacks` object:
```typescript
import type { ProgressCallbacks } from '../ai-rounds/types.js';

const roundProgress: ProgressCallbacks = {
  onRoundStart: (round, name) => {
    displayState.rounds.set(round, {
      roundNumber: round,
      name,
      status: 'running',
      elapsedMs: 0,
    });
    renderer.onRoundUpdate(displayState);
  },
  onRoundComplete: (round, tokens, cost) => {
    const rd = displayState.rounds.get(round);
    if (rd) {
      rd.status = 'done';
      rd.tokens = tokens;
      rd.cost = cost;
    }
    displayState.totalTokens = tracker.getTotalUsage().input + tracker.getTotalUsage().output;
    displayState.totalCost = tracker.getTotalCost();
    renderer.onRoundUpdate(displayState);
  },
  onRoundRetry: (round, delayMs, reason) => {
    const rd = displayState.rounds.get(round);
    if (rd) {
      rd.retrying = true;
      rd.retryDelayMs = delayMs;
      rd.retryReason = reason;
    }
    renderer.onRoundUpdate(displayState);
  },
  onRoundFail: (round, reason, affectedDocs) => {
    const rd = displayState.rounds.get(round);
    if (rd) {
      rd.status = 'failed';
      rd.retrying = false;
    }
    displayState.errors.push({
      source: `Round ${round}`,
      message: reason,
      affectedDocs,
    });
    renderer.onRoundUpdate(displayState);
  },
};
```

However, the `createRoundNStep` functions (e.g., `createRound1Step`) currently do NOT accept a `progress` parameter. They internally call `executeRound()`. We need to thread the progress through.

**Important approach decision:** Rather than modifying all 6 `createRoundNStep` functions (which would touch 6 more files and violate the file ownership constraint), use the DAG orchestrator's existing `onStepStart`/`onStepComplete`/`onStepFail` events plus the `onStepComplete` hook that already intercepts round results.

Replace the DAG orchestrator event hooks:
```typescript
const orchestrator = new DAGOrchestrator({
  onStepStart: (id, name) => {
    // AI round steps start with 'ai-round-'
    const match = id.match(/^ai-round-(\d+)$/);
    if (match) {
      const roundNum = parseInt(match[1], 10);
      const roundName = ROUND_NAMES[roundNum] ?? name;
      displayState.rounds.set(roundNum, {
        roundNumber: roundNum,
        name: roundName,
        status: 'running',
        elapsedMs: 0,
      });
      renderer.onRoundUpdate(displayState);
    }
  },
  onStepComplete: (result) => {
    const match = result.stepId.match(/^ai-round-(\d+)$/);
    if (match && result.data) {
      const roundNum = parseInt(match[1], 10);
      roundResults.set(roundNum, result.data as RoundExecutionResult<unknown>);

      // Update display state with round completion info
      const rd = displayState.rounds.get(roundNum);
      const roundData = result.data as RoundExecutionResult<unknown>;
      if (rd) {
        rd.status = roundData.status === 'degraded' ? 'failed' : 'done';
        rd.tokens = roundData.tokens;
        rd.cost = roundData.cost;
        rd.elapsedMs = result.duration;
      }
      displayState.totalTokens = tracker.getTotalUsage().input + tracker.getTotalUsage().output;
      displayState.totalCost = tracker.getTotalCost();
      renderer.onRoundUpdate(displayState);
    }

    // Detect render step completion for phase transition
    if (result.stepId === 'render') {
      // handled below after orchestrator.execute returns
    }
  },
  onStepFail: (result) => {
    const match = result.stepId.match(/^ai-round-(\d+)$/);
    if (match) {
      const roundNum = parseInt(match[1], 10);
      const rd = displayState.rounds.get(roundNum);
      if (rd) {
        rd.status = 'failed';
      }
      // Determine affected documents
      const affectedDocs = DOCUMENT_REGISTRY
        .filter(d => d.requiredRounds.includes(roundNum))
        .map(d => d.filename);
      displayState.errors.push({
        source: `Round ${roundNum}`,
        message: result.error instanceof Error ? result.error.message : String(result.error),
        affectedDocs,
      });
      renderer.onRoundUpdate(displayState);
    }
  },
});
```

This approach uses ONLY the existing DAG event hooks. It does NOT require modifying any of the 6 round step creator files. The round tokens/cost will be available on `RoundExecutionResult` since Plan 07-02 adds those fields.

**Step 7: Document rendering with progress**
Inside the render step's `execute` function, after each document is written, update display state and call the renderer:
```typescript
// After writeFile in the document loop:
displayState.renderedDocs.push(doc.filename);
renderer.onDocRendered(displayState);
```

Also after writing INDEX:
```typescript
displayState.renderedDocs.push('00-INDEX.md');
renderer.onDocRendered(displayState);
```

Set `displayState.phase = 'rendering'` at the start of the render step.

**Step 8: Completion summary**
After `orchestrator.execute` returns, update final state:
```typescript
displayState.phase = 'complete';
displayState.elapsedMs = Date.now() - startTime;
displayState.completionDocs = displayState.renderedDocs.length;
displayState.totalTokens = tracker.getTotalUsage().input + tracker.getTotalUsage().output;
displayState.totalCost = tracker.getTotalCost();
renderer.onComplete(displayState);
```

Remove the existing `logger.success(...)`, `logger.info(formatValidationLine(...))`, `logger.log(tracker.toSummary())`, `logger.warn(buildFailureReport(...))`, and `logger.info('Documents: ...')` lines. The renderer's `onComplete` handles the compact summary, and errors are accumulated in `displayState.errors` for the error summary section.

**Step 9: Static-only mode**
For the `staticOnly` branch at the top: use a simpler approach. The renderer is still used for the banner and static analysis progress, but since there are no AI rounds, skip straight to completion. Wire the same `onProgress` callback into `runStaticAnalysis` in the static-only path.

**Step 10: Error handling**
In the outer catch block, call `renderer.onError(displayState)` if there's a catastrophic error. Then `renderer.destroy()` in the finally.

**Key removals from generate.ts:**
- Remove all `logger.blank()`, `logger.info(...)`, `logger.success(...)`, `logger.warn(...)`, `logger.step(...)`, `logger.log(...)` calls that are related to pipeline progress.
- Keep `logger.error(err)` calls in the catch block (errors go to stderr, not suppressed).
- Remove the `console.log(formatTerminalSummary(result))` call in static-only mode.
- Remove the inline step logging from the DAG event hooks.
- Remove the `stepNames` Map (no longer needed — round names come from ROUND_NAMES).

**Key additions:**
- `extToLanguage()` helper function (local to generate.ts or in formatters — keep it local since it's specific to the generate command).
- Display state initialization and update code throughout the pipeline.
- try/finally block for renderer cleanup and logger unsuppression.
  </action>
  <verify>
1. `npx tsc --noEmit` — compiles with no errors.
2. `npm run build` — if build script exists, verify it succeeds.
3. Manual verification: `node dist/cli/index.js generate --static-only` — should show the banner line and analyzer progress (if there's a project to analyze), followed by the completion line.
4. Verify NO stray `console.log` calls remain in generate.ts (except inside the render step where the renderer handles output).
  </verify>
  <done>generate.ts uses the renderer for all progress output. TTY mode shows multi-line updating display. Non-TTY mode shows structured log lines. Logger is suppressed during renderer operation. Startup banner matches the Vite-style single line from CONTEXT.md. Completion summary matches the compact format from CONTEXT.md. Errors show inline + details at end.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. No `console.log` or `logger.*` calls for progress display remain in generate.ts (only error handling uses logger.error)
3. Display state is updated at every phase transition and event
4. renderer.destroy() is called in finally block (cursor restored)
5. logger.setSuppressed(false) is called in finally block
</verification>

<success_criteria>
- `handover generate` shows: banner -> analyzer progress -> round progress -> doc rendering -> completion summary
- TTY mode: multi-line in-place updates for analyzers and rounds
- Non-TTY mode: structured log lines with timestamps
- Errors display inline during pipeline, full details at end
- NO_COLOR produces ASCII output without color
- Cost warning appears when exceeding threshold
- Static-only mode shows banner + analyzer progress + summary
- Cursor is always restored (even on SIGINT/crash)
</success_criteria>

<output>
After completion, create `.planning/phases/07-terminal-ux/07-03-SUMMARY.md`
</output>
