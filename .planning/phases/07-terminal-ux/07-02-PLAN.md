---
phase: 07-terminal-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analyzers/coordinator.ts
  - src/ai-rounds/runner.ts
  - src/ai-rounds/types.ts
  - src/utils/rate-limiter.ts
  - src/context/tracker.ts
  - src/config/schema.ts
  - src/domain/types.ts
  - src/providers/base.ts
  - src/providers/anthropic.ts
  - src/ai-rounds/round-1-overview.ts
  - src/ai-rounds/round-2-modules.ts
  - src/ai-rounds/round-3-features.ts
  - src/ai-rounds/round-4-architecture.ts
  - src/ai-rounds/round-5-edge-cases.ts
  - src/ai-rounds/round-6-deployment.ts
autonomous: true

must_haves:
  truths:
    - "Static analysis coordinator emits per-analyzer start/done/fail events via the existing onProgress callback"
    - "AI round runner emits round start, round complete with tokens/cost, round retry with delay, and round fail with affected docs"
    - "retryWithBackoff exposes countdown delay and reason to callers via onRetry callback"
    - "TokenUsageTracker can compute cost per round and running total cost using a configurable model cost table"
    - "DAGEvents interface includes onStepRetry event that propagates retry countdown delay and reason"
    - "HandoverConfig includes optional costWarningThreshold field defaulting to 1.00"
  artifacts:
    - path: "src/ai-rounds/runner.ts"
      provides: "Extended executeRound with onRoundStart, onRoundComplete, onRoundRetry, onRoundFail callbacks"
      exports: ["executeRound", "ExecuteRoundOptions"]
    - path: "src/ai-rounds/types.ts"
      provides: "Extended RoundExecutionResult with tokens and cost fields; ProgressCallbacks interface"
      exports: ["RoundExecutionResult", "ProgressCallbacks"]
    - path: "src/utils/rate-limiter.ts"
      provides: "retryWithBackoff with onRetry callback exposing delay and reason"
      exports: ["retryWithBackoff", "RateLimiter"]
    - path: "src/context/tracker.ts"
      provides: "TokenUsageTracker with estimateCost method and model cost table"
      exports: ["TokenUsageTracker"]
    - path: "src/config/schema.ts"
      provides: "costWarningThreshold optional field in HandoverConfigSchema"
      contains: "costWarningThreshold"
    - path: "src/domain/types.ts"
      provides: "DAGEvents extended with onStepRetry event for retry countdown propagation"
      contains: "onStepRetry"
  key_links:
    - from: "src/ai-rounds/runner.ts"
      to: "src/ai-rounds/types.ts"
      via: "import ProgressCallbacks type"
      pattern: "ProgressCallbacks"
    - from: "src/ai-rounds/runner.ts"
      to: "src/context/tracker.ts"
      via: "tracker.estimateCost() called after round completion"
      pattern: "estimateCost"
    - from: "src/utils/rate-limiter.ts"
      to: "caller in runner.ts"
      via: "onRetry callback"
      pattern: "onRetry"
    - from: "src/domain/types.ts"
      to: "src/orchestrator/dag.ts"
      via: "DAGEvents.onStepRetry consumed by DAGOrchestrator"
      pattern: "onStepRetry"
---

<objective>
Extend the event pipeline so the coordinator, AI round runner, rate limiter, and token tracker emit the fine-grained progress events the terminal renderer needs.

Purpose: The existing code runs analyzers and AI rounds but emits minimal progress information (DAG-level step start/complete/fail only). The renderer needs per-analyzer status, per-round token/cost data, retry countdown information, and a cost estimation API. This plan adds those hooks without changing any visual output — that's Plan 07-03.

Output: Existing files modified with new event hooks, retry callback threading, and a cost calculation API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-terminal-ux/07-RESEARCH.md
@src/analyzers/coordinator.ts
@src/ai-rounds/runner.ts
@src/ai-rounds/types.ts
@src/utils/rate-limiter.ts
@src/context/tracker.ts
@src/config/schema.ts
@src/domain/types.ts
@src/providers/base.ts
@src/providers/anthropic.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cost calculation to TokenUsageTracker and costWarningThreshold to config</name>
  <files>src/context/tracker.ts, src/config/schema.ts</files>
  <action>
**`src/config/schema.ts`** — Add `costWarningThreshold` to the config schema:
- Add inside the `HandoverConfigSchema` z.object, at the top level (not nested): `costWarningThreshold: z.number().positive().optional()`.
- This is an optional field. When not set, the renderer will use a default of `1.00` (handled in the renderer, not in the schema default, so config stays clean for users who don't care about cost warnings).

**`src/context/tracker.ts`** — Extend `TokenUsageTracker` with cost calculation:

Add a static `MODEL_COSTS` table as a private static field:
```typescript
private static readonly MODEL_COSTS: Record<string, { inputPerMillion: number; outputPerMillion: number }> = {
  'claude-opus-4-6': { inputPerMillion: 15, outputPerMillion: 75 },
  'claude-opus-4-5': { inputPerMillion: 5, outputPerMillion: 25 },
  'claude-sonnet-4-5': { inputPerMillion: 3, outputPerMillion: 15 },
  'claude-haiku-4-5': { inputPerMillion: 1, outputPerMillion: 5 },
  'gpt-4o': { inputPerMillion: 2.5, outputPerMillion: 10 },
  'gpt-4o-mini': { inputPerMillion: 0.15, outputPerMillion: 0.6 },
  'default': { inputPerMillion: 15, outputPerMillion: 75 },
};
```

Add a `model` field to the constructor: `constructor(warnThreshold = 0.85, private readonly model: string = 'default')`.

Add method `estimateCost(inputTokens: number, outputTokens: number): number`:
- Look up model in `MODEL_COSTS`, fall back to `'default'`.
- Return `(inputTokens / 1_000_000) * costs.inputPerMillion + (outputTokens / 1_000_000) * costs.outputPerMillion`.

Add method `getRoundCost(roundNumber: number): number`:
- Find the round usage entry matching `roundNumber`, return `estimateCost(usage.inputTokens, usage.outputTokens)`. Return 0 if not found.

Add method `getTotalCost(): number`:
- Sum `estimateCost(r.inputTokens, r.outputTokens)` across all recorded rounds.

Add method `getRoundUsage(roundNumber: number): TokenUsage | undefined`:
- Find and return the round entry matching the given roundNumber from `this.rounds`.

These are pure additions — do NOT change the existing `recordRound`, `getTotalUsage`, `getRoundCount`, `getLastRound`, or `toSummary` methods.
  </action>
  <verify>Run `npx tsc --noEmit` — compiles with no errors. Verify the new methods exist by checking the type output.</verify>
  <done>TokenUsageTracker has estimateCost, getRoundCost, getTotalCost, and getRoundUsage methods. HandoverConfig has optional costWarningThreshold field. Existing behavior unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Extend AI round runner, rate limiter, and DAG events with progress callbacks</name>
  <files>src/ai-rounds/runner.ts, src/ai-rounds/types.ts, src/utils/rate-limiter.ts, src/domain/types.ts, src/providers/base.ts, src/providers/anthropic.ts, src/ai-rounds/round-1-overview.ts, src/ai-rounds/round-2-modules.ts, src/ai-rounds/round-3-features.ts, src/ai-rounds/round-4-architecture.ts, src/ai-rounds/round-5-edge-cases.ts, src/ai-rounds/round-6-deployment.ts, src/analyzers/coordinator.ts</files>
  <action>
**`src/ai-rounds/types.ts`** — Add a `ProgressCallbacks` interface:
```typescript
export interface ProgressCallbacks {
  onRoundStart?: (round: number, name: string) => void;
  onRoundComplete?: (round: number, tokens: number, cost: number) => void;
  onRoundRetry?: (round: number, delayMs: number, reason: string) => void;
  onRoundFail?: (round: number, reason: string, affectedDocs: string[]) => void;
}
```

Also add to `RoundExecutionResult<T>`:
- `tokens?: number` — Total tokens (input + output) for this round.
- `cost?: number` — Estimated dollar cost for this round.

These are optional fields added to the existing interface — existing code that doesn't set them will not break.

**`src/ai-rounds/runner.ts`** — Extend `ExecuteRoundOptions<T>`:
- Add optional `progress?: ProgressCallbacks` field.
- Add optional `roundName?: string` field (for display purposes).
- Add optional `affectedDocs?: string[]` field (documents that depend on this round, for failure reporting).

In the `executeRound` function:
- At the top, call `options.progress?.onRoundStart?.(roundNumber, options.roundName ?? `Round ${roundNumber}`)`.
- After `tracker.recordRound(...)` in the `attempt()` function, compute cost via `tracker.getRoundCost(roundNumber)` and total tokens `result.usage.inputTokens + result.usage.outputTokens`. Call `options.progress?.onRoundComplete?.(roundNumber, totalTokens, cost)`.
- Before the retry call (`return attempt(true)`), call `options.progress?.onRoundRetry?.(roundNumber, 0, 'quality')` (the 0 delay indicates an immediate retry, not a rate limit backoff).
- In the catch block (degraded fallback), call `options.progress?.onRoundFail?.(roundNumber, errorMessage, options.affectedDocs ?? [])`.
- Add `tokens` and `cost` fields to the returned `RoundExecutionResult` object: `tokens: total, cost: roundCost` (where these are computed from the tracker after recording).

**`src/utils/rate-limiter.ts`** — Extend `retryWithBackoff` options:
- Add optional `onRetry?: (attempt: number, delayMs: number, reason: string) => void` to the options object.
- In the retry loop, before the `await new Promise(setTimeout)` line, call: `options.onRetry?.(attempt + 1, Math.ceil(jitter), reason)` where `reason` is derived from the error (e.g., `err instanceof Error ? err.message : 'rate limited'`). Extract `reason` from the error object: if the error has a `message` property use it, otherwise use `'rate limited'`.
- This does NOT change the timing or behavior — just exposes the countdown info.

**`src/domain/types.ts`** — Extend `DAGEvents` interface with `onStepRetry`:
- Add `onStepRetry?: (stepId: string, attempt: number, delayMs: number, reason: string) => void;` to the `DAGEvents` interface, alongside the existing `onStepStart`, `onStepComplete`, `onStepFail`.
- This is a 1-line addition. The consumer side is wired in 07-03.

**Threading retry info from `retryWithBackoff` up to `generate.ts`:**
The rate-limit retry happens inside `AnthropicProvider.complete()` which calls `retryWithBackoff` with hard-coded options. To surface retry countdown information to the renderer, thread `onRetry` through the full call stack:

1. **`src/providers/base.ts`** — Add optional 3rd parameter to `LLMProvider.complete()`:
   ```typescript
   complete<T>(request: CompletionRequest, schema: z.ZodType<T>, options?: { onRetry?: (attempt: number, delayMs: number, reason: string) => void }): Promise<CompletionResult & { data: T }>;
   ```

2. **`src/providers/anthropic.ts`** — In `AnthropicProvider.complete()`, accept the optional `options` parameter and forward `options?.onRetry` to the `retryWithBackoff` options object:
   ```typescript
   async complete<T>(request, schema, options?) {
     return this.rateLimiter.withLimit(async () => {
       return retryWithBackoff(fn, {
         ...existingOptions,
         onRetry: options?.onRetry,  // forward to retryWithBackoff
       });
     });
   }
   ```

3. **`src/ai-rounds/runner.ts`** — Add optional `onRetry` to `ExecuteRoundOptions`. In `executeRound`, pass it through to `provider.complete()`:
   ```typescript
   const result = await provider.complete<T>(request, schema, { onRetry: options.onRetry });
   ```

4. **Round step creators** (`src/ai-rounds/round-1-overview.ts` through `round-6-deployment.ts`) — Add optional `onRetry` parameter to each `createRoundNStep` function and forward it to `executeRound`:
   ```typescript
   export function createRound1Step(
     provider, staticAnalysis, packedContext, config, tracker, estimateTokensFn,
     onRetry?: (attempt: number, delayMs: number, reason: string) => void,  // NEW
   ): StepDefinition {
     ...
     return executeRound<Round1Output>({
       ...existingOptions,
       onRetry,  // forward
     });
   }
   ```
   This is a mechanical 2-line change per file (add param, forward it). All 6 round step creators follow the same pattern.

The complete thread: `generate.ts` passes `onRetry` to `createRoundNStep` -> `executeRound` -> `provider.complete()` -> `retryWithBackoff.onRetry` fires -> callback propagates up to `generate.ts` -> `DAGEvents.onStepRetry` -> `renderer.onRoundUpdate` -> animated countdown display.

**`src/analyzers/coordinator.ts`** — The `onProgress` callback is already defined in `RunStaticAnalysisOptions` and called in `unwrap()`. Verify it fires correctly:
- Currently, `onProgress` is called with `(analyzerName, 'done' | 'fail')` after each analyzer settles, and `(analyzerName, 'start')` before `Promise.allSettled`.
- This is sufficient for the renderer. No code changes needed to coordinator.ts UNLESS the start events fire too early (before Promise.allSettled is called). Check: the current code fires all 8 start events immediately before the `allSettled` call — this is correct because all analyzers DO start concurrently. Leave as-is.

Actually, review the coordinator more carefully: the `for (const name of ANALYZER_NAMES) { onProgress?.(name, 'start'); }` loop fires all 8 starts BEFORE `Promise.allSettled`. This means all analyzers are reported as "running" immediately. The done/fail events fire inside `unwrap` which runs after allSettled. This is correct — the analyzers DO all start at once. No changes needed to coordinator.ts.

Remove coordinator.ts from files_modified if no changes end up being made. (It's listed for review verification only.)
  </action>
  <verify>Run `npx tsc --noEmit` — all modified files compile. The existing round step creators (round-1-overview.ts through round-6-deployment.ts) still work because the new fields are optional. Run a quick grep to confirm no existing call sites break: `grep -r "executeRound(" src/` — all existing calls should still compile since new params are optional.</verify>
  <done>AI round runner emits progress callbacks for start/complete/retry/fail. Rate limiter exposes retry delay/reason via onRetry callback. DAGEvents has onStepRetry event. LLMProvider.complete() accepts optional onRetry callback, threaded through AnthropicProvider to retryWithBackoff. TokenUsageTracker has cost estimation. Config has optional costWarningThreshold. All changes are backward-compatible (new fields are optional).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Existing tests (if any) still pass: `npm test`
3. All new callbacks are optional — existing code paths unaffected
4. `grep -r "executeRound\|retryWithBackoff\|TokenUsageTracker" src/` confirms existing call sites unchanged
</verification>

<success_criteria>
- TokenUsageTracker.estimateCost() returns dollar amounts based on model cost table
- TokenUsageTracker.getTotalCost() sums across all rounds
- executeRound emits progress callbacks at key lifecycle points
- retryWithBackoff exposes delay and reason via onRetry callback
- DAGEvents.onStepRetry is defined and available for orchestrator consumers
- LLMProvider.complete() accepts optional onRetry callback
- AnthropicProvider forwards onRetry to retryWithBackoff
- All 6 round step creators accept optional onRetry parameter and forward to executeRound
- HandoverConfig.costWarningThreshold is a valid optional numeric field
- All changes are backward-compatible — no existing code breaks
</success_criteria>

<output>
After completion, create `.planning/phases/07-terminal-ux/07-02-SUMMARY.md`
</output>
