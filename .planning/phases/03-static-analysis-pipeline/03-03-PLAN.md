---
phase: 03-static-analysis-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/analyzers/git-history.ts
  - src/analyzers/ast-analyzer.ts
  - src/analyzers/test-analyzer.ts
  - src/analyzers/doc-analyzer.ts
autonomous: true

must_haves:
  truths:
    - "GitHistory analyzer extracts branch patterns, commit history, file churn, and contributor data with configurable depth"
    - "ASTAnalyzer wraps Phase 2 ParserService to batch-extract exports, imports, and function signatures from supported files"
    - "TestAnalyzer identifies test files, test frameworks, and test counts by pattern matching"
    - "DocAnalyzer detects READMEs, docs folders, JSDoc, and docstrings"
    - "GitHistory gracefully returns empty result when not in a git repository"
  artifacts:
    - path: "src/analyzers/git-history.ts"
      provides: "STAT-03: Git commit patterns, branch analysis, churn, contributors"
      exports: ["analyzeGitHistory"]
    - path: "src/analyzers/ast-analyzer.ts"
      provides: "STAT-06: Batch AST extraction via Phase 2 ParserService"
      exports: ["analyzeAST"]
    - path: "src/analyzers/test-analyzer.ts"
      provides: "STAT-07: Test file locations, frameworks, test counts"
      exports: ["analyzeTests"]
    - path: "src/analyzers/doc-analyzer.ts"
      provides: "STAT-08: README, docs folder, JSDoc, docstring detection"
      exports: ["analyzeDocs"]
  key_links:
    - from: "src/analyzers/git-history.ts"
      to: "simple-git"
      via: "simpleGit() for branch/log/raw operations"
      pattern: "simpleGit\\("
    - from: "src/analyzers/ast-analyzer.ts"
      to: "src/parsing/index.ts"
      via: "createParserService() from Phase 2"
      pattern: "createParserService\\("
    - from: "src/analyzers/test-analyzer.ts"
      to: "src/analyzers/types.ts"
      via: "TestResult schema conformance"
      pattern: "TestResult"
---

<objective>
Build four complex static analyzers: GitHistory (STAT-03), ASTAnalyzer (STAT-06), TestAnalyzer (STAT-07), and DocAnalyzer (STAT-08). These are more infrastructure-dependent -- GitHistory wraps simple-git, ASTAnalyzer wraps the Phase 2 ParserService.

Purpose: These analyzers capture version control patterns, code structure, test infrastructure, and documentation coverage -- the deeper intelligence needed for meaningful handover documentation.
Output: Four analyzer modules in `src/analyzers/`, each exporting a single async function conforming to the AnalyzerFn signature.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-static-analysis-pipeline/03-RESEARCH.md
@.planning/phases/03-static-analysis-pipeline/03-01-SUMMARY.md
@src/analyzers/types.ts
@src/analyzers/context.ts
@src/parsing/index.ts
@src/parsing/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GitHistory and ASTAnalyzer</name>
  <files>
    src/analyzers/git-history.ts
    src/analyzers/ast-analyzer.ts
  </files>
  <action>
    **git-history.ts (STAT-03):**

    Import `simpleGit` from 'simple-git', types from './types.js'.

    Export `async function analyzeGitHistory(ctx: AnalysisContext): Promise<AnalyzerResult<GitHistoryResult>>`:
    1. Wrap entire body in try-catch returning `{ success: false, error, elapsed }` on failure
    2. Create git instance: `simpleGit(ctx.rootDir)`
    3. Check if git repo: `await git.checkIsRepo()`. If not, return `{ success: true, data: emptyGitResult('Not a git repository'), elapsed }`
    4. **Branch analysis:**
       - `await git.branch(['-a', '--sort=-committerdate'])` to get all branches sorted by last commit
       - Detect branching strategy from naming patterns:
         - git-flow: has `develop` + `release/*` branches
         - feature-branch: has `feature/*` but no `develop`
         - trunk-based: 3 or fewer branches
         - unknown: otherwise
       - Collect evidence strings for the detected strategy
       - Identify active branches (committed to within last 30 days) and stale branches (no commits in 90+ days)
       - Record default branch from `branches.current`
       - Count local and remote branches separately
    5. **Commit history with configurable depth:**
       - If `ctx.gitDepth === 'full'`, no --since filter; otherwise default to 6 months ago
       - Use `git.raw(['log', '--all', '--format=%H|%an|%ae|%aI|%s', ...sinceArg])` for raw log
       - Parse each line into { hash, author, email, date, message }
       - Take most recent 100 commits for `recentCommits` array
    6. **Most-changed files (churn):**
       - Use `git.raw(['log', '--all', '--name-only', '--format=', ...sinceArg])` to get file names from commits
       - Count occurrences per file path, sort descending, take top 30
    7. **Activity by month:**
       - From parsed commits, group by YYYY-MM, count commits per month
    8. **Contributors:**
       - From parsed commits, group by `name|email`, count commits per contributor, sort descending
    9. **File ownership (secondary metric per discretion):**
       - From the name-only log data, for each of the top 30 most-changed files, find the contributor with the most commits to that file
       - Use `git.raw(['log', '--all', '--format=%an', '--follow', '--', filepath])` for top files only (limit to 30 to avoid N+1 performance issue)
    10. Return full `GitHistoryResult` with all data and empty warnings array

    Define helper `emptyGitResult(warning: string): GitHistoryResult` returning zeroed-out structure with the warning.

    Per LOCKED decision: primary focus is branch patterns. Per discretion: include churn/ownership/contributor data as secondary metrics.
    Per LOCKED decision: configurable depth defaults to 6 months, `ctx.gitDepth === 'full'` means complete history.

    **ast-analyzer.ts (STAT-06):**

    Import `createParserService` and `isSupportedFile` from '../parsing/index.js', `readFile` from 'node:fs/promises', types from './types.js', `isBinaryFile` from './file-discovery.js'.

    Export `async function analyzeAST(ctx: AnalysisContext): Promise<AnalyzerResult<ASTResult>>`:
    1. Wrap in try-catch, track elapsed
    2. Create parser service: `const service = await createParserService()`
    3. Initialize: `await service.init()`
    4. Filter `ctx.files` to supported, non-binary files using `isSupportedFile(file.path)` and `!isBinaryFile(file.extension)`
    5. Process files in batches of 30 (avoid overwhelming WASM memory):
       - For each file, read content, call `service.parseFile(file.absolutePath, content)`
       - Use content-hash cache: `ctx.cache.isUnchanged(file.path, hash)` to skip unchanged files (but for v1, since we need the ParsedFile output, cache check is a future optimization -- just note it and parse all)
       - Collect ParsedFile results. On individual file parse failure, log warning and continue (don't crash pipeline)
    6. Dispose service: `service.dispose()` in a finally block
    7. Build summary: count totalFunctions, totalClasses, totalExports, totalImports across all ParsedFiles. Build languageBreakdown Record counting files per language.
    8. Return `{ success: true, data: { files: parsedFiles, summary }, elapsed }`
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify: analyzeGitHistory and analyzeAST are exported, handle error cases gracefully, and return AnalyzerResult types.</verify>
  <done>GitHistory extracts branch patterns with strategy detection, commit history with configurable depth, file churn, contributor data, and file ownership. ASTAnalyzer wraps Phase 2 ParserService for batch extraction with proper WASM lifecycle management.</done>
</task>

<task type="auto">
  <name>Task 2: Implement TestAnalyzer and DocAnalyzer</name>
  <files>
    src/analyzers/test-analyzer.ts
    src/analyzers/doc-analyzer.ts
  </files>
  <action>
    **test-analyzer.ts (STAT-07):**

    Import `readFile` from 'node:fs/promises', `basename`/`dirname` from 'node:path', types from './types.js'.

    Define test file patterns for framework detection:
    ```
    FRAMEWORK_PATTERNS = {
      vitest: { filePatterns: [/\.test\.[tj]sx?$/, /\.spec\.[tj]sx?$/], configFiles: ['vitest.config.ts', 'vitest.config.js', 'vitest.config.mts'], testPatterns: [/\b(it|test|describe)\s*\(/g] },
      jest: { filePatterns: [/\.test\.[tj]sx?$/, /\.spec\.[tj]sx?$/], configFiles: ['jest.config.ts', 'jest.config.js', 'jest.config.mjs'], testPatterns: [/\b(it|test|describe)\s*\(/g] },
      mocha: { filePatterns: [/\.test\.[tj]sx?$/, /\.spec\.[tj]sx?$/], configFiles: ['.mocharc.yml', '.mocharc.json', '.mocharc.js'], testPatterns: [/\b(it|describe)\s*\(/g] },
      pytest: { filePatterns: [/^test_.*\.py$/, /.*_test\.py$/], configFiles: ['pytest.ini', 'pyproject.toml', 'setup.cfg'], testPatterns: [/\bdef\s+test_/g] },
      go_test: { filePatterns: [/_test\.go$/], configFiles: [], testPatterns: [/\bfunc\s+Test[A-Z]/g] },
      rust_test: { filePatterns: [/tests\/.*\.rs$/], configFiles: [], testPatterns: [/#\[test\]/g, /#\[cfg\(test\)\]/g] },
    }
    ```

    Export `async function analyzeTests(ctx: AnalysisContext): Promise<AnalyzerResult<TestResult>>`:
    1. Wrap in try-catch, track elapsed
    2. Identify test files: for each file in ctx.files, check basename against all framework filePatterns. Record matching framework.
    3. Detect frameworks: check ctx.files for framework config files. Also check package.json devDependencies for vitest/jest/mocha if a package.json was found.
    4. For each test file, read content and count test patterns (it/test/describe calls, def test_ functions, etc.). This gives approximate test count.
    5. Look for coverage data: check for `coverage/` directory files (lcov.info, coverage-summary.json) in ctx.files
    6. Build result: testFiles array (path, framework, testCount), frameworks list, hasConfig boolean, configFiles list, coverageDataPath
    7. Build summary: totalTestFiles, totalTests (sum of testCounts), frameworksDetected
    8. Return `{ success: true, data: { testFiles, frameworks, hasConfig, configFiles, coverageDataPath, summary }, elapsed }`

    **doc-analyzer.ts (STAT-08):**

    Import `readFile` from 'node:fs/promises', `basename`/`dirname` from 'node:path', types from './types.js', `isBinaryFile` from './file-discovery.js'.

    Define README_PATTERNS: `/^readme(\.(md|txt|rst|adoc))?$/i`
    Define DOC_FOLDER_PATTERNS: `['docs', 'doc', 'documentation', 'wiki', '.github']`

    Define inline doc patterns for detecting JSDoc/docstrings:
    - JS/TS: `/\/\*\*[\s\S]*?\*\//` (JSDoc blocks)
    - Python: `/("""[\s\S]*?"""|'''[\s\S]*?''')/` (docstrings)
    - Rust: `///` or `//!` (rustdoc comments)

    Export `async function analyzeDocs(ctx: AnalysisContext): Promise<AnalyzerResult<DocResult>>`:
    1. Wrap in try-catch, track elapsed
    2. Find READMEs: filter ctx.files where basename matches README_PATTERNS. Collect paths.
    3. Find docs folder: check if any file's directory path starts with a DOC_FOLDER_PATTERNS entry. Record the folder path.
    4. Find doc files: filter files within docs folder(s) or matching doc extensions (.md, .txt, .rst, .adoc)
    5. Inline doc coverage: for a sample of non-binary source files (up to 100), read content and check for inline doc patterns. Count files with at least one doc comment. Calculate percentage.
    6. Build result: readmes, docsFolder, docFiles, inlineDocCoverage
    7. Build summary: hasReadme (readmes.length > 0), hasDocsFolder (docsFolder !== null), docFileCount, inlineDocPercentage
    8. Return `{ success: true, data: { readmes, docsFolder, docFiles, inlineDocCoverage, summary }, elapsed }`
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify: analyzeTests and analyzeDocs are exported and return AnalyzerResult types.</verify>
  <done>TestAnalyzer identifies test files across 6 framework patterns with approximate test counts. DocAnalyzer detects READMEs, docs folders, and inline documentation coverage.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All four analyzer files exist: git-history.ts, ast-analyzer.ts, test-analyzer.ts, doc-analyzer.ts
3. Each exports a single async function accepting AnalysisContext
4. Each returns AnalyzerResult<T> with success/error/elapsed envelope
5. GitHistory handles non-git repos gracefully (returns empty result with warning)
6. ASTAnalyzer properly initializes and disposes ParserService in try/finally
7. TestAnalyzer detects vitest, jest, mocha, pytest, go_test, rust_test frameworks
8. DocAnalyzer finds READMEs and calculates inline doc coverage percentage
</verification>

<success_criteria>
- GitHistory detects branching strategy (git-flow/feature-branch/trunk-based/unknown) with evidence
- GitHistory respects configurable depth (default 6 months, full for complete history)
- GitHistory includes churn, contributor, and file ownership secondary metrics
- ASTAnalyzer reuses Phase 2 ParserService with proper WASM init/dispose lifecycle
- ASTAnalyzer processes files in batches and handles individual file failures
- TestAnalyzer identifies test files for JS/TS, Python, Go, and Rust frameworks
- DocAnalyzer finds READMEs, docs folders, and measures inline documentation coverage
- All four analyzers compile and conform to AnalyzerFn signature
</success_criteria>

<output>
After completion, create `.planning/phases/03-static-analysis-pipeline/03-03-SUMMARY.md`
</output>
