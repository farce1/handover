---
phase: 03-static-analysis-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/analyzers/file-tree.ts
  - src/analyzers/dependency-graph.ts
  - src/analyzers/todo-scanner.ts
  - src/analyzers/env-scanner.ts
autonomous: true

must_haves:
  truths:
    - "FileTree analyzer counts files, directories, sizes, and line counts from the shared FileEntry list"
    - "DependencyGraph analyzer parses package.json, Cargo.toml, go.mod, requirements.txt, pyproject.toml with dev vs production separation"
    - "TodoScanner finds TODO, FIXME, HACK, XXX, NOTE, WARN, DEPRECATED, REVIEW, OPTIMIZE, TEMP with categorization and issue references"
    - "EnvScanner detects .env files and environment variable references in source code"
    - "Malformed manifests produce warnings, not crashes"
  artifacts:
    - path: "src/analyzers/file-tree.ts"
      provides: "STAT-01: Directory structure, file types, sizes, line counts"
      exports: ["analyzeFileTree"]
    - path: "src/analyzers/dependency-graph.ts"
      provides: "STAT-02: Package manifest parsing with 5 formats"
      exports: ["analyzeDependencies"]
    - path: "src/analyzers/todo-scanner.ts"
      provides: "STAT-04: TODO/FIXME comment scanning with categories and issue refs"
      exports: ["scanTodos"]
    - path: "src/analyzers/env-scanner.ts"
      provides: "STAT-05: Environment variable detection from .env files and code references"
      exports: ["scanEnvVars"]
  key_links:
    - from: "src/analyzers/dependency-graph.ts"
      to: "smol-toml"
      via: "parse() for Cargo.toml and pyproject.toml"
      pattern: "parse.*smol-toml|parseTOML"
    - from: "src/analyzers/todo-scanner.ts"
      to: "src/analyzers/types.ts"
      via: "TodoResult schema"
      pattern: "TodoItem|TodoResult"
    - from: "src/analyzers/file-tree.ts"
      to: "src/analyzers/context.ts"
      via: "AnalysisContext.files consumption"
      pattern: "ctx\\.files"
---

<objective>
Build four simpler static analyzers: FileTree (STAT-01), DependencyGraph (STAT-02), TodoScanner (STAT-04), and EnvScanner (STAT-05). Each is a standalone module exporting an analyzer function that receives AnalysisContext and returns a typed AnalyzerResult.

Purpose: These four analyzers cover file structure, external dependency discovery, technical debt markers, and environment configuration detection -- core handover intelligence that requires no git or AST infrastructure.
Output: Four analyzer modules in `src/analyzers/`, each exporting a single async function conforming to the AnalyzerFn signature.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-static-analysis-pipeline/03-RESEARCH.md
@.planning/phases/03-static-analysis-pipeline/03-01-SUMMARY.md
@src/analyzers/types.ts
@src/analyzers/context.ts
@src/analyzers/file-discovery.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FileTree and DependencyGraph analyzers</name>
  <files>
    src/analyzers/file-tree.ts
    src/analyzers/dependency-graph.ts
  </files>
  <action>
    **file-tree.ts (STAT-01):**

    Import `readFile` from 'node:fs/promises', `dirname`/`join` from 'node:path', types from './types.js', `isBinaryFile` from './file-discovery.js'.

    Export `async function analyzeFileTree(ctx: AnalysisContext): Promise<AnalyzerResult<FileTreeResult>>`:
    1. Wrap entire body in try-catch returning `{ success: false, error, elapsed }` on failure
    2. Track elapsed time with `Date.now()` start/end
    3. Build `filesByExtension` Record by iterating `ctx.files` and counting extensions
    4. Count lines: for non-binary files, read content and count `\n` occurrences. Process in batches of 50 to avoid memory pressure. Track totalLines.
    5. Build directory set: extract unique directory paths from all file paths using `dirname()`. Count totalDirs.
    6. Sort files by size descending, take top 20 as `largestFiles` with path, size, lines
    7. Build `directoryTree` array: for each unique directory, count children (files directly inside). For each file, record path/type/size/lines. Limit depth to avoid enormous trees -- include top 3 directory levels plus any file directly referenced as largest.
    8. Return `{ success: true, data: { totalFiles, totalDirs, totalLines, totalSize, filesByExtension, largestFiles, directoryTree }, elapsed }`

    **dependency-graph.ts (STAT-02):**

    Import `readFile` from 'node:fs/promises', `parse as parseTOML` from 'smol-toml', types from './types.js'.

    Define MANIFEST_PATTERNS constant: `{ 'package.json': 'npm', 'Cargo.toml': 'cargo', 'go.mod': 'go', 'requirements.txt': 'pip', 'pyproject.toml': 'pip' }`.

    Export `async function analyzeDependencies(ctx: AnalysisContext): Promise<AnalyzerResult<DependencyResult>>`:
    1. Wrap in try-catch, track elapsed
    2. Find manifest files: filter `ctx.files` for paths matching MANIFEST_PATTERNS keys (check `basename(file.path)` against the keys). Also check for manifests in subdirectories (monorepo support).
    3. For each manifest, call the appropriate parser function wrapped in its own try-catch:
       - `parsePackageJson(content)` — JSON.parse, extract dependencies/devDependencies/peerDependencies/optionalDependencies with correct type labels
       - `parseCargoToml(content)` — parseTOML, extract [dependencies] as production, [dev-dependencies] as development, [build-dependencies] as development. Handle inline table `{ version = "x" }` and string `"x"` value formats
       - `parseGoMod(content)` — regex-based: match `require (...)` blocks and single `require` lines. All deps are production type
       - `parseRequirementsTxt(content)` — line-based: skip comments (#) and flags (-r, -e, -i). Extract name and version spec. All deps are production type
       - `parsePyprojectToml(content)` — parseTOML, extract [project].dependencies as production, [project].optional-dependencies as development
    4. On manifest parse failure: push to warnings array with file path and error message. Continue with remaining manifests (per user decision: "warn and skip, continue with what's parseable")
    5. Return `{ success: true, data: { manifests: [...], warnings }, elapsed }`

    Each parser is a standalone function within the module (not exported, internal helper). Each returns `DependencyInfo[]`.

    Dev vs production separation is a LOCKED decision -- must be tracked separately per the user's explicit requirement.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify: analyzeFileTree and analyzeDependencies are exported and accept AnalysisContext parameter.</verify>
  <done>FileTree analyzer produces file/dir counts, sizes, line counts, extension breakdown, and largest files. DependencyGraph analyzer parses all 5 manifest formats with dev/prod separation and handles malformed manifests gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Implement TodoScanner and EnvScanner analyzers</name>
  <files>
    src/analyzers/todo-scanner.ts
    src/analyzers/env-scanner.ts
  </files>
  <action>
    **todo-scanner.ts (STAT-04):**

    Import `readFile` from 'node:fs/promises', types from './types.js', `isBinaryFile` from './file-discovery.js'.

    Define category map (per LOCKED user decision):
    ```
    CATEGORY_MAP: Record<string, string> = {
      FIXME: 'bugs', HACK: 'bugs', XXX: 'bugs',
      TODO: 'tasks',
      NOTE: 'notes', WARN: 'notes',
      DEPRECATED: 'debt', TEMP: 'debt',
      OPTIMIZE: 'optimization', REVIEW: 'optimization',
    }
    ```

    Build marker regex from CATEGORY_MAP keys: `\b(TODO|FIXME|HACK|...)\b[:\s]\s*(.*)` with case-insensitive flag.

    Define issue reference regex: `/(?:#(\d+)|([A-Z]{2,}-\d+))/g` to capture `#123` and `GH-456` / `JIRA-789` patterns.

    Export `async function scanTodos(ctx: AnalysisContext): Promise<AnalyzerResult<TodoResult>>`:
    1. Wrap in try-catch, track elapsed
    2. Filter ctx.files to non-binary files only
    3. For each file, read content and scan line-by-line:
       - Apply MARKER_REGEX to each line
       - On match: extract marker (uppercase), look up category, extract text, extract line number
       - Apply ISSUE_REF_REGEX to the full line to find issue references
       - Build TodoItem: { marker, category, text, file: file.path, line: lineNumber, issueRefs }
    4. Process files in batches of 50 for memory efficiency
    5. Build summary: total count, byCategory Record counting items per category
    6. Return `{ success: true, data: { items, summary }, elapsed }`

    Per user decision: context per item is "line text, file path, and line number only (no surrounding code)".

    **env-scanner.ts (STAT-05):**

    Import `readFile` from 'node:fs/promises', `join`/`basename` from 'node:path', types from './types.js', `isBinaryFile` from './file-discovery.js'.

    Define ENV_FILE_PATTERNS: `.env`, `.env.local`, `.env.development`, `.env.production`, `.env.test`, `.env.example`, `.env.sample`.

    Define ENV_REFERENCE_REGEX for detecting env var usage in code: `process\.env\.([A-Z_][A-Z0-9_]*)`, `os\.environ\[['"]([A-Z_][A-Z0-9_]*)['"]\]`, `os\.getenv\(['"]([A-Z_][A-Z0-9_]*)['"]\)`, `env::var\(['"]([A-Z_][A-Z0-9_]*)['"]\)`, `os\.Getenv\(['"]([A-Z_][A-Z0-9_]*)['"]\)`. Combine into a single regex with alternation.

    Export `async function scanEnvVars(ctx: AnalysisContext): Promise<AnalyzerResult<EnvResult>>`:
    1. Wrap in try-catch, track elapsed
    2. Find .env files: filter ctx.files where `basename(path)` matches ENV_FILE_PATTERNS. Also check for `.env*` patterns
    3. For each .env file, read content and extract variable names (lines matching `^[A-Z_][A-Z0-9_]*=`)
    4. For each non-binary source file, read content and scan for ENV_REFERENCE_REGEX matches. Record file, line number, variable name
    5. Process source file scanning in batches of 50
    6. Collect warnings (e.g., ".env file found without .env.example" — potential secret exposure risk)
    7. Return `{ success: true, data: { envFiles, envReferences, warnings }, elapsed }`
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify: scanTodos and scanEnvVars are exported and return AnalyzerResult types.</verify>
  <done>TodoScanner finds all 10 marker types with categorization and issue references. EnvScanner detects .env files and environment variable references across TS/Python/Rust/Go code patterns.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All four analyzer files exist: file-tree.ts, dependency-graph.ts, todo-scanner.ts, env-scanner.ts
3. Each exports a single async function accepting AnalysisContext
4. Each returns AnalyzerResult<T> with success/error/elapsed envelope
5. DependencyGraph handles all 5 manifest formats
6. TodoScanner uses the full 10-marker set with correct category mapping
7. All functions handle errors gracefully (try-catch returning error result, not throwing)
</verification>

<success_criteria>
- FileTree accurately counts files, dirs, lines, sizes, and extensions
- DependencyGraph parses all 5 manifest formats with dev/prod separation
- DependencyGraph catches and warns on malformed manifests without crashing
- TodoScanner matches all 10 markers (TODO, FIXME, HACK, XXX, NOTE, WARN, DEPRECATED, REVIEW, OPTIMIZE, TEMP)
- TodoScanner categorizes items into bugs/tasks/notes/debt/optimization
- TodoScanner captures #123 and JIRA-456 issue references
- EnvScanner finds .env files and env var references in 4 language patterns
- All four analyzers compile and conform to AnalyzerFn signature
</success_criteria>

<output>
After completion, create `.planning/phases/03-static-analysis-pipeline/03-02-SUMMARY.md`
</output>
