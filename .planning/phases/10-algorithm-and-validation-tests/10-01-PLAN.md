---
phase: 10-algorithm-and-validation-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/context/packer.test.ts
  - src/providers/factory.test.ts
autonomous: true

must_haves:
  truths:
    - 'packFiles() tests exercise all 7 code paths including empty input, small-project fast-path, changed-file priority, oversized two-pass, normal full, AST signatures fallback, non-AST first-20-lines fallback, and skip'
    - 'packFiles() budget boundary test confirms usedTokens and utilizationPercent are correct when budget is exactly exhausted'
    - "packFiles() error resilience test confirms a rejected getFileContent promise produces tier='skip' with tokens=0"
    - 'generateSignatureSummary() tests produce deterministic output strings with correct header, exported functions, exported classes, exported constants, import summaries, and non-exported symbol exclusion'
    - 'validateProviderConfig() tests cover all 5 throw paths asserting the correct ProviderError.code for each'
    - 'validateProviderConfig() non-throw path confirms local providers (ollama with model) do not throw for missing API key'
  artifacts:
    - path: 'src/context/packer.test.ts'
      provides: 'packFiles and generateSignatureSummary unit tests'
    - path: 'src/providers/factory.test.ts'
      provides: 'validateProviderConfig unit tests'
  key_links:
    - from: 'src/context/packer.test.ts'
      to: 'src/context/packer.ts'
      via: 'import { packFiles, generateSignatureSummary, OVERSIZED_THRESHOLD_TOKENS }'
    - from: 'src/providers/factory.test.ts'
      to: 'src/providers/factory.ts'
      via: 'import { validateProviderConfig }'
    - from: 'src/providers/factory.test.ts'
      to: 'src/utils/errors.ts'
      via: 'import { ProviderError }'
---

<objective>
Write unit tests for `packFiles()`, `generateSignatureSummary()`, and `validateProviderConfig()` — the codebase's most complex algorithm (7 code paths) and its fail-fast provider validation (5 throw paths).

Purpose: Cover context packing boundary conditions, oversized file handling, signature generation formatting, and provider validation error paths so regressions in these critical algorithms are caught immediately.

Output: Two test files (`packer.test.ts`, `factory.test.ts`) with all code paths exercised.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-algorithm-and-validation-tests/10-RESEARCH.md

@src/context/packer.ts
@src/context/types.ts
@src/analyzers/types.ts
@src/parsing/types.ts
@src/providers/factory.ts
@src/providers/presets.ts
@src/utils/errors.ts
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write packFiles and generateSignatureSummary tests</name>
  <files>src/context/packer.test.ts</files>
  <action>
Create `src/context/packer.test.ts` with comprehensive tests for both `packFiles()` and `generateSignatureSummary()`.

**Imports:** `packFiles`, `generateSignatureSummary`, `OVERSIZED_THRESHOLD_TOKENS` from `./packer.js`. Types: `FilePriority`, `TokenBudget` from `./types.js`, `ASTResult` from `../analyzers/types.js`, `ParsedFile` from `../parsing/types.js`.

**Local factories (NOT shared):**

- `charTokens = (text: string) => text.length` — deterministic 1-char = 1-token estimator
- `mkBudget(fileContentBudget: number): TokenBudget` — constructs `{ total: fileContentBudget + 7096, promptOverhead: 3000, outputReserve: 4096, fileContentBudget }`
- `mkScored(path: string, score: number): FilePriority` — constructs scored file with zeroed breakdown
- `emptyAST: ASTResult` — `{ files: [], summary: { totalFunctions: 0, totalClasses: 0, totalExports: 0, totalImports: 0, languageBreakdown: {} } }`
- `mkParsedFile(overrides?: Partial<ParsedFile>): ParsedFile` — returns base shape with all required fields (path, language, parserUsed, functions, classes, imports, exports, constants, reExports, lineCount, parseErrors) merged with overrides
- `mkContentFn(map: Record<string, string>)` — returns `vi.fn()` that resolves to `map[path]` or rejects for unknown paths
- `mkASTResult(files: ParsedFile[]): ASTResult` — wraps files array with zeroed summary

**packFiles() test scenarios (describe block "packFiles"):**

1. **Empty input guard** — `scored = []`, assert `files.length === 0`, `metadata.totalFiles === 0`, `metadata.usedTokens === 0`, `metadata.utilizationPercent === 0`
2. **Small-project fast-path** — 2 files totaling 200 chars, budget 10000. Assert all files `tier === 'full'`, `metadata.fullFiles === 2`, `metadata.skippedFiles === 0`, `metadata.signatureFiles === 0`
3. **Changed file forced full** — 2 files, budget tight enough that only 1 fits as full. Pass `changedFiles = new Set(['b.ts'])` where b.ts is the changed file. Assert b.ts gets `tier: 'full'`
4. **Changed file exceeds remaining budget falls through** — 1 changed file of 500 chars, budget of 100. Assert it does NOT get full tier (falls through to signatures or skip)
5. **Oversized file: signatures + all sections fit** — File with `fullTokens > OVERSIZED_THRESHOLD_TOKENS`, score 50, with AST parsed data including an exported function. Budget large enough for sig+sections. Assert tier is `'full'` (combined) and content contains the section label marker `// ---`
6. **Oversized file: greedy section subset** — Same oversized setup but budget only fits signatures + some sections. Assert `tier === 'signatures'`
7. **Oversized file: signatures only** — Budget fits only signatures, not even one section. Assert `tier === 'signatures'`, content does NOT contain `// ---` section markers
8. **Normal file: full content** — Single 100-char file, budget 500. Assert `tier === 'full'`, content matches original
9. **Normal file: AST signatures fallback** — 2 files: first consumes most budget at full, second is 200 chars but only 50 remain. Second has AST data. Assert second file `tier === 'signatures'`, content starts with `// FILE:`
10. **Normal file: non-AST first-20-lines fallback** — Same tight budget but file has no AST entry. Assert `tier === 'signatures'`, content starts with `// FILE:`
11. **File read failure: rejected promise produces skip** — `getFileContent` rejects for one path. Assert `tier === 'skip'`, `tokens === 0`
12. **Budget exactly exhausted** — File content exactly equals budget. Assert `metadata.usedTokens` equals `metadata.budgetTokens`, `metadata.utilizationPercent === 100`
13. **Budget boundary: one char over** — File 1 char larger than budget in main loop. Assert it falls to signatures or skip, not full

**generateSignatureSummary() test scenarios (describe block "generateSignatureSummary"):**

1. **Header line** — `mkParsedFile({ path: 'src/foo.ts', lineCount: 99 })`, assert output contains `// FILE: src/foo.ts (99 lines)`
2. **Exported async function with typed params** — Add function to `functions[]` and matching entry to `exports[]`. Assert contains `export async function formatDate(date: Date, format: string): string`
3. **Exported sync function without return type** — Assert contains `export function doThing(x)` (no return suffix)
4. **Non-exported function excluded** — Function in `functions[]` but NOT in `exports[]`. Assert `result` does NOT contain function name
5. **Exported class with public methods** — Class in `classes[]` with `methods` array containing public methods, matching `exports[]` entry. Assert contains `export class MyClass { method(p: T): R }`
6. **Class private methods excluded** — Class with private method. Assert private method name NOT in output
7. **Exported constant with type** — `constants[]` entry with `isExported: true`, `type: 'number'`. Assert contains `export const MAX_SIZE: number`
8. **Exported constant without type** — `isExported: true`, no type. Assert contains `export const DEFAULT_NAME` without colon suffix
9. **Non-exported constant excluded** — `isExported: false`. Assert constant name NOT in output
10. **Import summary line** — 2 imports. Assert contains `// 2 imports from: ./types, lodash`
11. **No imports: no import line** — Empty imports. Assert does NOT contain `imports from`
12. **All together** — Function + class + constant + imports. Assert all sections present in output, header at start

Use `test.each` for the export/non-export pattern where applicable. All assertions use explicit `toContain`, `not.toContain`, `toBe` — no snapshot tests.
</action>
<verify>
Run `npx vitest run src/context/packer.test.ts` — all tests pass, zero failures.
Run `npx vitest run` — full suite still passes (no regressions).
</verify>
<done>
packFiles() has at least 13 passing tests covering all 7 code paths plus boundary conditions and error resilience. generateSignatureSummary() has at least 12 passing tests covering header, functions, classes, constants, imports, and exclusion of non-exported symbols. No calls to real filesystem — all via injected vi.fn().
</done>
</task>

<task type="auto">
  <name>Task 2: Write validateProviderConfig tests</name>
  <files>src/providers/factory.test.ts</files>
  <action>
Create `src/providers/factory.test.ts` with comprehensive tests for `validateProviderConfig()`.

**Imports:** `validateProviderConfig` from `./factory.js`, `ProviderError` from `../utils/errors.js`. Type: `HandoverConfig` from `../config/schema.js`.

**Setup:** `afterEach(() => { vi.unstubAllEnvs(); })` — clean up env stubs after every test.

**Local factory:**

- `baseConfig(overrides?: Partial<HandoverConfig>): HandoverConfig` — Returns valid anthropic config with all required fields: `{ provider: 'anthropic', output: './handover', audience: 'human', include: ['**/*'], exclude: [], analysis: { concurrency: 4, staticOnly: false }, project: {}, contextWindow: { pin: [], boost: [] }, ...overrides }`. For configs needing a non-Zod-valid provider (like 'unknown-provider'), use type assertion: `{ ...baseConfig(), provider: 'not-real' as HandoverConfig['provider'] }`.

**Test scenarios (describe block "validateProviderConfig"):**

1. **PROVIDER_UNKNOWN** — `provider: 'not-real' as HandoverConfig['provider']`. Assert throws `ProviderError`, catch and inspect `error.code === 'PROVIDER_UNKNOWN'`
2. **PROVIDER_OLLAMA_NO_MODEL** — `provider: 'ollama'`, no `model` field. Assert throws `ProviderError` with `code === 'PROVIDER_OLLAMA_NO_MODEL'`
3. **PROVIDER_AZURE_NO_BASE_URL** — `provider: 'azure-openai'`, no `baseUrl`. `vi.stubEnv('AZURE_OPENAI_API_KEY', 'test-key')` to get past the API key check. Assert throws `ProviderError` with `code === 'PROVIDER_AZURE_NO_BASE_URL'`
4. **PROVIDER_NO_API_KEY** — `provider: 'anthropic'`, `vi.stubEnv('ANTHROPIC_API_KEY', undefined)`. Assert throws `ProviderError` with `code === 'PROVIDER_NO_API_KEY'`
5. **PROVIDER_CUSTOM_NO_BASE_URL** — `provider: 'custom' as HandoverConfig['provider']`, no `baseUrl`. Assert throws `ProviderError` with `code === 'PROVIDER_CUSTOM_NO_BASE_URL'`
6. **Non-throw: valid anthropic config** — `vi.stubEnv('ANTHROPIC_API_KEY', 'sk-test-key')`. Assert `expect(() => validateProviderConfig(config)).not.toThrow()`
7. **Non-throw: local provider (ollama with model) skips API key check** — `provider: 'ollama'`, `model: 'llama3.1:8b'`. Assert does NOT throw (isLocal skips env var check)
8. **Non-throw: valid openai config** — `provider: 'openai'`, `vi.stubEnv('OPENAI_API_KEY', 'sk-test')`. Assert does NOT throw

For each throw test, use the pattern:

```typescript
try {
  validateProviderConfig(config);
  expect.unreachable('should have thrown');
} catch (e) {
  expect(e).toBeInstanceOf(ProviderError);
  expect((e as ProviderError).code).toBe('EXPECTED_CODE');
}
```

This avoids the `.toThrow()` + separate try/catch duplication. The `expect.unreachable()` call (Vitest built-in) fails the test if execution reaches it, proving the throw happened.
</action>
<verify>
Run `npx vitest run src/providers/factory.test.ts` — all tests pass, zero failures.
Run `npx vitest run` — full suite still passes.
</verify>
<done>
validateProviderConfig() has at least 8 passing tests covering all 5 throw paths (PROVIDER_UNKNOWN, PROVIDER_OLLAMA_NO_MODEL, PROVIDER_AZURE_NO_BASE_URL, PROVIDER_NO_API_KEY, PROVIDER_CUSTOM_NO_BASE_URL) plus 3 non-throw paths. Each throw test asserts the correct ProviderError.code. vi.stubEnv used for all env var manipulation with afterEach cleanup.
</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/context/packer.test.ts` — all packFiles and generateSignatureSummary tests pass
2. `npx vitest run src/providers/factory.test.ts` — all validateProviderConfig tests pass
3. `npx vitest run` — full test suite passes with no regressions
4. `npx tsc --noEmit` — no TypeScript errors introduced
</verification>

<success_criteria>

- packer.test.ts contains 25+ passing tests covering all 7 packFiles code paths, budget boundaries, error resilience, and 12 generateSignatureSummary format assertions
- factory.test.ts contains 8+ passing tests covering all 5 throw paths and 3 non-throw paths
- Zero calls to real filesystem in packer tests (all via injected vi.fn)
- Zero real env var leaks in factory tests (all via vi.stubEnv + afterEach cleanup)
- Full vitest run and typecheck pass
  </success_criteria>

<output>
After completion, create `.planning/phases/10-algorithm-and-validation-tests/10-01-SUMMARY.md`
</output>
