---
phase: 06-context-efficiency
plan: 03
type: execute
wave: 2
depends_on: ['06-01', '06-02']
files_modified:
  - src/ui/components.ts
  - src/ui/types.ts
  - src/cli/generate.ts
  - src/ui/ci-renderer.ts
  - src/ui/terminal-renderer.ts
autonomous: true

must_haves:
  truths:
    - 'Each completed round shows its own token count, cost, and savings line (when savings exist) in the terminal'
    - 'The completion summary shows per-round breakdown with tokens sent, received, and dollar cost'
    - 'All-cached runs skip the token summary entirely'
    - 'Full runs with no savings show totals without mentioning savings'
    - 'Document renderers execute in parallel via Promise.allSettled with error isolation'
    - 'Parallel render shows aggregate progress and time saved vs sequential'
    - "The file coverage line shows 'Incremental run (N files changed)' or 'Full run' label"
  artifacts:
    - path: 'src/ui/components.ts'
      provides: 'renderRoundSavings(), renderIncrementalLabel(), updated renderRoundBlock with per-round savings, updated renderCompletionSummary with per-round breakdown, renderRenderProgress()'
      contains: 'renderRoundSavings'
    - path: 'src/ui/types.ts'
      provides: 'RoundDisplayState extended with cacheReadTokens, cacheCreationTokens; DisplayState extended with render timing fields'
      contains: 'cacheReadTokens'
    - path: 'src/cli/generate.ts'
      provides: 'Parallel document rendering via Promise.allSettled, render timing, per-round savings in display state, incremental label in file coverage'
      contains: 'Promise.allSettled'
  key_links:
    - from: 'src/cli/generate.ts'
      to: 'src/ui/components.ts'
      via: 'displayState fields consumed by render functions'
      pattern: 'cacheReadTokens|renderTimingMs'
    - from: 'src/cli/generate.ts'
      to: 'src/context/tracker.ts'
      via: 'getRoundCacheSavings() called for per-round savings display'
      pattern: 'getRoundCacheSavings'
---

<objective>
Implement per-round token summary with savings display, parallel document rendering with timing, and incremental run labeling — the user-facing culmination of Phase 6.

Purpose: Users see exactly what each round cost, how much caching saved, and how parallel rendering reduced wall time. This is the visible payoff of the infrastructure built in Plans 01 and 02. Addresses EFF-03, EFF-04, and the display requirements from locked decisions.

Output: Per-round savings lines, completion summary with breakdown, parallel rendering with timing, incremental run label, green-coded savings amounts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-context-efficiency/06-01-SUMMARY.md
@.planning/phases/06-context-efficiency/06-02-SUMMARY.md
@src/ui/components.ts
@src/ui/types.ts
@src/ui/formatters.ts
@src/cli/generate.ts
@src/context/tracker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-round savings display, incremental run label, and completion summary with per-round breakdown</name>
  <files>src/ui/components.ts, src/ui/types.ts</files>
  <action>
**In `src/ui/types.ts`:**

1. Extend `RoundDisplayState` with cache token fields:

   ```typescript
   /** Cache read tokens from Anthropic prompt caching (undefined for non-Anthropic). */
   cacheReadTokens?: number;
   /** Cache creation tokens from Anthropic prompt caching (undefined for non-Anthropic). */
   cacheCreationTokens?: number;
   /** Dollar savings from caching for this round. */
   cacheSavingsDollars?: number;
   /** Token savings from caching for this round. */
   cacheSavingsTokens?: number;
   /** Percentage of tokens saved from caching for this round. */
   cacheSavingsPercent?: number;
   ```

2. Extend `DisplayState` with render timing and per-round cost tracking:

   ```typescript
   /** Milliseconds taken by parallel document rendering. */
   renderTimingMs?: number;
   /** Estimated sequential render time for savings comparison. */
   renderSequentialEstimateMs?: number;
   /** Per-round token and cost data for the completion summary. Populated after all rounds complete. */
   roundSummaries?: Array<{
     round: number;
     inputTokens: number;
     outputTokens: number;
     cost: number;
     savings?: { tokens: number; percent: number; dollars: number };
   }>;
   ```

3. Add `onRenderStart` and `onRenderDone` methods to the `Renderer` interface:
   ```typescript
   onRenderStart?(state: DisplayState): void;
   onRenderDone?(state: DisplayState): void;
   ```
   Use optional methods (with `?`) so existing renderer implementations don't need to implement them immediately.

**In `src/ui/components.ts`:**

1. Add `renderRoundSavings()` function:

   ```typescript
   /**
    * Render a savings line for a round that had cache/packing savings.
    * Format: "  Saved 12,400 tokens (62%, ~$0.03)" in green.
    * Per locked decision: express in all three units.
    */
   export function renderRoundSavings(
     tokensSaved: number,
     pctSaved: number,
     dollarsSaved: number,
   ): string {
     const tokStr = tokensSaved.toLocaleString();
     const pctStr = Math.round(pctSaved * 100);
     const dolStr = dollarsSaved < 0.01 ? '<$0.01' : `~$${dollarsSaved.toFixed(2)}`;
     return pc.green(`    Saved ${tokStr} tokens (${pctStr}%, ${dolStr})`);
   }
   ```

2. Add `renderIncrementalLabel()` function for the file coverage line:

   ```typescript
   /**
    * Render the incremental/full run label shown before AI rounds.
    * Per locked decision: "Incremental run (3 files changed)" or "Full run".
    */
   export function renderRunLabel(isIncremental: boolean, changedFileCount?: number): string {
     if (isIncremental && changedFileCount !== undefined) {
       return `Incremental run (${changedFileCount} file${changedFileCount !== 1 ? 's' : ''} changed)`;
     }
     return 'Full run';
   }
   ```

3. Update `renderFileCoverage()` to include the run label and unchanged count:
   Modify the existing `renderFileCoverage` to accept optional incremental metadata:

   ```typescript
   export function renderFileCoverage(
     coverage: {
       analyzing: number;
       ignored: number;
       total: number;
     },
     incremental?: {
       isIncremental: boolean;
       changedFileCount?: number;
       unchangedFileCount?: number;
     },
   ): string {
     const sep = pc.dim(' \u00B7 ');
     const bullet = pc.dim('\u25C6');

     const parts: string[] = [];

     // Run label first (per locked decision)
     if (incremental) {
       parts.push(renderRunLabel(incremental.isIncremental, incremental.changedFileCount));
     }

     parts.push(`${coverage.total} files`);
     parts.push(`${pc.cyan(String(coverage.analyzing))} analyzing`);

     // Show unchanged count on incremental runs (per locked decision: "Analyzed 12 files, skipped 48 unchanged")
     if (incremental?.isIncremental && incremental.unchangedFileCount !== undefined) {
       parts.push(`${pc.dim(String(incremental.unchangedFileCount))} unchanged`);
     }

     parts.push(`${pc.dim(String(coverage.ignored))} ignored`);

     return `${bullet} ${parts.join(sep)}`;
   }
   ```

4. Update `renderRoundBlock()` to include per-round savings:
   In the `case 'done':` branch, after the existing parts array construction, add a savings line:

   ```typescript
   case 'done': {
     const tokenStr = formatTokens(rd.tokens ?? 0);
     const durationStr = formatDuration(rd.elapsedMs);
     const parts = [`${pc.green(SYMBOLS.done)} ${roundLabel}`, tokenStr, durationStr];
     if (!isLocal && rd.cost !== undefined) {
       parts.push(pc.yellow(formatCost(rd.cost)));
     }
     lines.push(`  ${parts.filter(Boolean).join(sep)}`);
     // Per-round savings line (per locked decision: show when savings exist)
     if (rd.cacheSavingsTokens && rd.cacheSavingsTokens > 0 && rd.cacheSavingsPercent !== undefined && rd.cacheSavingsDollars !== undefined) {
       lines.push(renderRoundSavings(rd.cacheSavingsTokens, rd.cacheSavingsPercent, rd.cacheSavingsDollars));
     }
     break;
   }
   ```

5. Update `renderCompletionSummary()` to show per-round breakdown:
   After the existing completion line, add per-round breakdown from `state.roundSummaries`:

   ```typescript
   export function renderCompletionSummary(state: DisplayState): string[] {
     const sep = pc.dim(' \u00B7 ');
     const parts = [
       `${pc.green(SYMBOLS.done)} ${state.completionDocs} documents`,
       formatTokens(state.totalTokens),
     ];
     if (!state.isLocal) {
       parts.push(pc.yellow(formatCost(state.totalCost)));
     }
     parts.push(formatDuration(state.elapsedMs));
     const completionLine = parts.join(sep);

     const lines: string[] = [completionLine];

     // Per-round breakdown (per locked decision: each round shows tokens and cost)
     if (state.roundSummaries && state.roundSummaries.length > 0) {
       for (const rs of state.roundSummaries) {
         const roundParts: string[] = [
           `  Round ${rs.round}`,
           formatTokens(rs.inputTokens + rs.outputTokens),
         ];
         if (!state.isLocal) {
           roundParts.push(pc.yellow(formatCost(rs.cost)));
         }
         lines.push(pc.dim(roundParts.join(sep)));

         // Savings line for this round (per locked decision: tokens, percentage, dollars)
         if (rs.savings && rs.savings.tokens > 0) {
           lines.push(
             renderRoundSavings(rs.savings.tokens, rs.savings.percent, rs.savings.dollars),
           );
         }
       }
     }

     if (state.parallelSavedMs !== undefined && state.parallelSavedMs > 0) {
       lines.push(renderParallelSavings(state.parallelSavedMs));
     }

     // Render timing line (per locked decision: show time saved by parallel rendering)
     if (state.renderTimingMs !== undefined && state.renderSequentialEstimateMs !== undefined) {
       const savedMs = state.renderSequentialEstimateMs - state.renderTimingMs;
       if (savedMs > 500) {
         // Only show if meaningful
         const docCount = state.completionDocs;
         const actualSec = (state.renderTimingMs / 1000).toFixed(1);
         const savedSec = formatDuration(savedMs);
         lines.push(
           pc.dim(
             `  Rendered ${docCount} docs in ${actualSec}s (saved ~${savedSec} vs sequential)`,
           ),
         );
       }
     }

     return lines;
   }
   ```

6. Add `renderRenderProgress()` function for the aggregate render progress:
   ```typescript
   /**
    * Render the aggregate render start/done lines.
    * Per locked decision: "Rendering N documents..." then done — no per-doc status.
    */
   export function renderRenderProgress(docCount: number): string {
     return `${pc.dim(SYMBOLS.running)} Rendering ${docCount} documents...`;
   }
   ```
     </action>
     <verify>
   Run `npx tsc --noEmit` — no type errors. Run `npm test` — existing tests pass. Confirm `renderRoundSavings`, `renderRunLabel`, `renderRenderProgress` functions exist in components.ts. Confirm `RoundDisplayState` has `cacheReadTokens` field and `DisplayState` has `roundSummaries` field.
     </verify>
     <done>
   The display layer renders per-round savings with green-coded tokens/percentage/dollars, shows "Incremental run (N files changed)" or "Full run" labels, includes per-round breakdown in the completion summary, and has render timing display support. All display is driven by DisplayState fields populated by generate.ts.
     </done>
   </task>

<task type="auto">
  <name>Task 2: Parallel document rendering and per-round savings wiring in generate.ts</name>
  <files>src/cli/generate.ts, src/ui/ci-renderer.ts, src/ui/terminal-renderer.ts</files>
  <action>
**In `src/cli/generate.ts`:**

1. **Wire per-round cache savings into display state.** In `onStepComplete`, after setting `rd.tokens` and `rd.cost`, add cache savings from the tracker:

   ```typescript
   // Wire cache savings into round display state (from Plan 02's tracker extensions)
   const cacheSavings = tracker.getRoundCacheSavings(roundNum);
   if (cacheSavings && rd) {
     rd.cacheReadTokens = roundData.usage?.cacheReadTokens;
     rd.cacheCreationTokens = roundData.usage?.cacheCreationTokens;
     rd.cacheSavingsTokens = cacheSavings.tokensSaved;
     rd.cacheSavingsPercent = cacheSavings.percentSaved;
     rd.cacheSavingsDollars = cacheSavings.dollarsSaved;
   }
   ```

   Note: `roundData` is `result.data as RoundExecutionResult<unknown>`. The `usage` field from Plan 02 carries `cacheReadTokens`/`cacheCreationTokens`.

2. **Update the file coverage emission to include incremental metadata.** Currently the code calls `renderer.onFileCoverage(displayState)`. The `renderFileCoverage` function (updated in Task 1) needs the incremental metadata. Since `displayState` already has `isIncremental`, `changedFileCount`, and `unchangedFileCount` from Plan 01, the renderer will read these from the state. No additional wiring needed here — just verify the renderer implementations pass the metadata through.

3. **Convert sequential document rendering to parallel.** In the render step's `execute()` function, replace the sequential `for (const doc of selectedDocs)` loop with `Promise.allSettled`:

   Replace the sequential rendering block (from `// Render each selected document` through the loop adding statuses) with:

   ```typescript
   // Parallel document rendering (EFF-04)
   const renderStart = Date.now();
   const docsToRender = selectedDocs.filter((doc) => doc.id !== '00-index');

   // Emit render start (aggregate progress only — per locked decision)
   if (renderer.onRenderStart) {
     renderer.onRenderStart(displayState);
   }

   const renderResults = await Promise.allSettled(
     docsToRender.map(async (doc) => {
       const docStart = Date.now();
       const content = doc.render(ctx);

       if (content === '') {
         return { doc, content: '', skipped: true, durationMs: Date.now() - docStart };
       }

       await writeFile(join(outputDir, doc.filename), content, 'utf-8');
       return { doc, content, skipped: false, durationMs: Date.now() - docStart };
     }),
   );

   const renderTimingMs = Date.now() - renderStart;

   // Process results in input order (Promise.allSettled preserves order)
   const statuses: DocumentStatus[] = [];
   let sequentialEstimateMs = 0;
   const renderFailures: Array<{ doc: (typeof docsToRender)[0]; error: unknown }> = [];

   for (let i = 0; i < renderResults.length; i++) {
     const result = renderResults[i];
     const doc = docsToRender[i];

     if (result.status === 'rejected') {
       // Error isolation: record failure, continue (per locked decision)
       renderFailures.push({ doc, error: result.reason });
       statuses.push({
         id: doc.id,
         filename: doc.filename,
         title: doc.title,
         status: 'not-generated',
         reason: `Render failed: ${result.reason instanceof Error ? result.reason.message : String(result.reason)}`,
       });
     } else if (result.value.skipped) {
       statuses.push({
         id: doc.id,
         filename: doc.filename,
         title: doc.title,
         status: 'not-generated',
         reason: 'Required AI analysis unavailable',
       });
       sequentialEstimateMs += result.value.durationMs;
     } else {
       displayState.renderedDocs.push(doc.filename);
       const roundStatus = determineDocStatus(doc.requiredRounds, roundResults, true);
       statuses.push({
         id: doc.id,
         filename: doc.filename,
         title: doc.title,
         status: roundStatus,
       });
       sequentialEstimateMs += result.value.durationMs;
     }
   }

   // Report render failures as errors (per locked decision: report at the end)
   for (const failure of renderFailures) {
     displayState.errors.push({
       source: `Render: ${failure.doc.filename}`,
       message: failure.error instanceof Error ? failure.error.message : String(failure.error),
     });
   }

   // Store render timing for completion summary
   displayState.renderTimingMs = renderTimingMs;
   displayState.renderSequentialEstimateMs = sequentialEstimateMs;
   ```

   Keep the existing code that adds non-selected document statuses and renders INDEX last (after the parallel batch).

   Emit render done:

   ```typescript
   if (renderer.onRenderDone) {
     renderer.onRenderDone(displayState);
   }
   ```

4. **Build per-round summaries before completion.** After `displayState.totalCost = tracker.getTotalCost();` and before `renderer.onComplete(displayState);`, build the roundSummaries array:

   ```typescript
   // Build per-round summaries for completion display (per locked decision: per-round breakdown)
   const roundSummaries: DisplayState['roundSummaries'] = [];
   for (const [roundNum, rd] of displayState.rounds) {
     if (rd.status === 'cached') continue; // Skip cached rounds (no API call)
     if (rd.status !== 'done' && rd.status !== 'failed') continue;

     const usage = tracker.getRoundUsage(roundNum);
     if (!usage) continue;

     const cost = tracker.getRoundCost(roundNum);
     const cacheSavings = tracker.getRoundCacheSavings(roundNum);

     roundSummaries.push({
       round: roundNum,
       inputTokens: usage.inputTokens,
       outputTokens: usage.outputTokens,
       cost,
       savings: cacheSavings
         ? {
             tokens: cacheSavings.tokensSaved,
             percent: cacheSavings.percentSaved,
             dollars: cacheSavings.dollarsSaved,
           }
         : undefined,
     });
   }

   // Per locked decision: skip summary on all-cached runs (no API calls made)
   if (roundSummaries.length > 0) {
     displayState.roundSummaries = roundSummaries;
   }
   ```

5. **Update renderers to pass incremental metadata to renderFileCoverage.**

   In `src/ui/ci-renderer.ts` and `src/ui/terminal-renderer.ts`, wherever `renderFileCoverage(state.fileCoverage)` is called, update the call to pass the incremental metadata:

   ```typescript
   renderFileCoverage(state.fileCoverage, {
     isIncremental: state.isIncremental ?? false,
     changedFileCount: state.changedFileCount,
     unchangedFileCount: state.unchangedFileCount,
   });
   ```

   Also implement `onRenderStart` and `onRenderDone` in both renderers:
   - **TerminalRenderer**: `onRenderStart` can be a no-op (progress shown in completion summary). `onRenderDone` can also be a no-op.
   - **CIRenderer**: `onRenderStart` logs `[render] Rendering N documents...`. `onRenderDone` logs `[render] Done in X.Xs`.
     </action>
     <verify>
     Run `npx tsc --noEmit` — no type errors. Run `npm test` — existing tests pass. Confirm that the render step uses `Promise.allSettled` instead of a sequential for loop. Confirm `displayState.roundSummaries` is populated before `renderer.onComplete`. Confirm both renderers call `renderFileCoverage` with incremental metadata.
     </verify>
     <done>
     Document rendering is parallelized via Promise.allSettled with error isolation. Per-round cache savings are wired from the tracker into RoundDisplayState and shown in the completion summary. The file coverage line includes the incremental run label and unchanged file count. Render timing is measured and displayed showing time saved vs sequential. All-cached runs skip the token summary entirely.
     </done>
     </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npm test` passes — all existing tests green
3. Document rendering uses `Promise.allSettled` (not sequential for loop)
4. Per-round savings display uses green color coding with tokens/percentage/dollars
5. Completion summary includes per-round breakdown with costs
6. "Incremental run (N files changed)" label appears in file coverage
7. Parallel render timing shows "Rendered N docs in Xs (saved ~Ys vs sequential)"
8. All-cached runs: no token summary shown
9. Full runs with no savings: totals only, no savings mentioned
</verification>

<success_criteria>

- Per-round savings lines appear for rounds that had cache hits (Anthropic rounds 2-6)
- Completion summary shows per-round token counts and costs
- All-cached runs skip the summary entirely
- Full runs without savings show totals only
- Document rendering completes faster than sequential (measured by render timing)
- Failed renders don't abort other documents
- Incremental run label and unchanged count appear in file coverage line
  </success_criteria>

<output>
After completion, create `.planning/phases/06-context-efficiency/06-03-SUMMARY.md`
</output>
