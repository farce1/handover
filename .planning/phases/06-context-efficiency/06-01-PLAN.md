---
phase: 06-context-efficiency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analyzers/cache.ts
  - src/context/packer.ts
  - src/cli/generate.ts
  - src/ui/types.ts
autonomous: true

must_haves:
  truths:
    - 'On an incremental run where only some files changed, only changed files are packed at full tier — unchanged files receive signatures tier'
    - "The terminal displays 'Incremental run (N files changed)' at the start of an incremental run and 'Full run' on first runs"
    - 'The file coverage line shows counts for both analyzed and unchanged files'
    - 'Budget enforcement still applies to changed files — they get priority but cannot blow the budget'
  artifacts:
    - path: 'src/analyzers/cache.ts'
      provides: 'getChangedFiles() public method returning Set<string> of changed file paths'
      contains: 'getChangedFiles'
    - path: 'src/context/packer.ts'
      provides: 'changedFiles parameter in packFiles() forcing changed files to full tier with budget enforcement'
      contains: 'changedFiles'
    - path: 'src/cli/generate.ts'
      provides: 'Wiring of changed-files detection into packFiles() call and incremental run label in display state'
      contains: 'getChangedFiles'
    - path: 'src/ui/types.ts'
      provides: 'DisplayState extended with incremental run metadata'
      contains: 'isIncremental'
  key_links:
    - from: 'src/cli/generate.ts'
      to: 'src/analyzers/cache.ts'
      via: 'getChangedFiles() called after buildAnalysisContext'
      pattern: 'getChangedFiles'
    - from: 'src/cli/generate.ts'
      to: 'src/context/packer.ts'
      via: 'changedFiles set passed to packFiles()'
      pattern: 'changedFiles'
---

<objective>
Implement changed-files context packing so incremental runs send only changed files at full detail to the LLM, with proper budget enforcement and terminal labeling.

Purpose: Reduce token count on incremental runs by detecting which files changed since the last run and forcing only those to full tier, while unchanged files fall to signatures tier. This is the foundational efficiency gain for EFF-01.

Output: `getChangedFiles()` on AnalysisCache, `changedFiles` parameter on `packFiles()`, incremental run label and updated file coverage in generate.ts display state.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/analyzers/cache.ts
@src/context/packer.ts
@src/cli/generate.ts
@src/ui/types.ts
@src/context/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getChangedFiles() to AnalysisCache and extend packFiles() with changed-files tier forcing</name>
  <files>src/analyzers/cache.ts, src/context/packer.ts</files>
  <action>
**In `src/analyzers/cache.ts`:**

Add a public method `getChangedFiles()` to the `AnalysisCache` class:

```typescript
getChangedFiles(currentHashes: Map<string, string>): Set<string> {
  const changed = new Set<string>();
  for (const [path, currentHash] of currentHashes) {
    if (!this.isUnchanged(path, currentHash)) {
      changed.add(path);
    }
  }
  return changed;
}
```

This compares current file content hashes against cached hashes and returns the set of changed (or new) file paths. Place it after the existing `update()` method.

**In `src/context/packer.ts`:**

1. Add an optional `changedFiles?: Set<string>` parameter to the `packFiles()` function signature (last parameter, after `getFileContent`).

2. In the main greedy packing loop (the `for (const entry of scored)` block), add changed-file priority BEFORE the existing normal file tier assignment. After the file-read check and before the oversized check:

```typescript
// Changed-file priority: force full tier for changed files (budget-enforced)
if (changedFiles && changedFiles.size > 0 && changedFiles.has(entry.path)) {
  if (content !== undefined && fullTokens <= remaining) {
    packedFiles.push({
      path: entry.path,
      tier: 'full',
      content,
      tokens: fullTokens,
      score: entry.score,
    });
    remaining -= fullTokens;
    continue;
  }
  // Changed file exceeds remaining budget — fall through to normal tier logic
  // so it can still get signatures instead of being skipped entirely
}
```

Key design: Changed files get priority in the queue but still consume from `remaining`. If a changed file exceeds the remaining budget, it falls through to normal tier logic (may get signatures). This prevents budget blowout per Pitfall 3 in research.

3. The small-project optimization (where `totalEstimatedTokens <= budget.fileContentBudget`) does NOT need modification — when everything fits, all files already get full tier regardless.
   </action>
   <verify>
   Run `npx tsc --noEmit` — no type errors. Run `npm test` — existing tests pass. Confirm `getChangedFiles` is exported from cache.ts and `changedFiles` parameter exists on `packFiles`.
   </verify>
   <done>
   AnalysisCache has a public `getChangedFiles(currentHashes)` method returning `Set<string>`. The `packFiles()` function accepts an optional `changedFiles` set and forces changed files to full tier with budget enforcement. Existing behavior is unchanged when `changedFiles` is undefined.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Wire changed-files detection into generate.ts and add incremental run label to display state</name>
  <files>src/cli/generate.ts, src/ui/types.ts</files>
  <action>
**In `src/ui/types.ts`:**

Add incremental run metadata fields to the `DisplayState` interface:

```typescript
/** Whether this is an incremental run (some files changed, some unchanged). */
isIncremental?: boolean;
/** Number of files that changed since last run (only set on incremental runs). */
changedFileCount?: number;
/** Number of files skipped as unchanged (only set on incremental runs). */
unchangedFileCount?: number;
```

Place these after the existing `streamVisible` field.

**In `src/cli/generate.ts`:**

1. Import `AnalysisCache` (the class, not just `hashContent`) at the top of the file:

   ```typescript
   import { hashContent, AnalysisCache } from '../analyzers/cache.js';
   ```

2. In the static-analysis step's `execute()` function, after the fingerprint computation loop (where `fileEntries` is built) and before the language detection, create an `AnalysisCache` instance and detect changed files:

   ```typescript
   // Detect changed files for incremental context packing (EFF-01)
   const analysisCache = new AnalysisCache(join(rootDir, '.handover', 'cache', 'analysis.json'));
   await analysisCache.load();

   const currentHashes = new Map<string, string>();
   for (const entry of fileEntries) {
     if (entry.contentHash) {
       currentHashes.set(entry.path, entry.contentHash);
     }
   }

   const changedFiles = analysisCache.getChangedFiles(currentHashes);
   const isIncremental = analysisCache.size > 0 && changedFiles.size < currentHashes.size;
   ```

   Note: `isIncremental` is true only when there IS a prior cache AND not all files are changed. On first run, `analysisCache.size === 0` so `isIncremental` is false.

3. Pass `changedFiles` to the `packFiles()` call:

   ```typescript
   packedContext = await packFiles(
     scored,
     result.ast,
     budget,
     estimateTokensFn,
     getFileContent,
     isIncremental ? changedFiles : undefined, // Only pass on incremental runs
   );
   ```

4. After the `packFiles()` call, set incremental run metadata on `displayState`:

   ```typescript
   // Set incremental run metadata for display
   if (isIncremental) {
     displayState.isIncremental = true;
     displayState.changedFileCount = changedFiles.size;
     displayState.unchangedFileCount = currentHashes.size - changedFiles.size;
   }
   ```

5. Update the file coverage indicator to include unchanged count on incremental runs. Modify the existing `displayState.fileCoverage` assignment:

   ```typescript
   displayState.fileCoverage = {
     analyzing: packedContext.metadata.fullFiles + packedContext.metadata.signatureFiles,
     ignored: packedContext.metadata.skippedFiles,
     total: packedContext.metadata.totalFiles,
   };
   ```

   This stays the same — the coverage indicator already shows the right numbers because unchanged files now get signatures tier instead of full.

6. Add verbose logging for per-file decisions (locked decision: `-v` reveals per-file decisions):

   ```typescript
   if (options.verbose && isIncremental) {
     process.stderr.write(
       `[verbose] Incremental run: ${changedFiles.size} changed, ${currentHashes.size - changedFiles.size} unchanged\n`,
     );
     for (const path of changedFiles) {
       process.stderr.write(`[verbose]   changed: ${path}\n`);
     }
   }
   ```

7. Update the analysis cache with current hashes so the NEXT run can detect changes:

   ```typescript
   // Update analysis cache for next run's change detection
   for (const [path, hash] of currentHashes) {
     analysisCache.update(path, hash);
   }
   await analysisCache.save();
   ```

   Place this after the `packFiles()` call.
   </action>
   <verify>
   Run `npx tsc --noEmit` — no type errors. Run `npm test` — existing tests pass. Verify that `DisplayState` now has `isIncremental`, `changedFileCount`, and `unchangedFileCount` fields.
   </verify>
   <done>
   The generate.ts pipeline detects changed files via AnalysisCache, passes them to packFiles() on incremental runs, sets incremental run metadata on DisplayState, logs per-file decisions in verbose mode, and persists hashes for the next run. First runs behave identically to before (no changedFiles passed). Incremental runs force changed files to full tier and label the run accordingly.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npm test` passes — all existing tests green
3. `getChangedFiles()` exists on AnalysisCache class
4. `packFiles()` accepts optional `changedFiles` parameter
5. `DisplayState` has `isIncremental`, `changedFileCount`, `unchangedFileCount` fields
</verification>

<success_criteria>

- On a second run with some files changed, only changed files get full tier — unchanged files get signatures
- Budget enforcement prevents changed files from exceeding the token budget
- First runs (no prior cache) behave identically to current behavior
- DisplayState carries incremental run metadata for downstream rendering
  </success_criteria>

<output>
After completion, create `.planning/phases/06-context-efficiency/06-01-SUMMARY.md`
</output>
