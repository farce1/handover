---
phase: 19-http-transport-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/schema.ts
  - src/cli/index.ts
  - src/cli/serve.ts
  - src/mcp/server.ts
autonomous: true

must_haves:
  truths:
    - "handover serve defaults to stdio transport when no flags or config are set"
    - "handover serve --transport http selects HTTP transport mode for the current run"
    - "handover serve --port 8080 overrides the default HTTP port"
    - "CLI flag --transport overrides serve.transport in .handover.yml"
    - "serve.transport config accepts only 'stdio' or 'http' with stdio as default"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "ServeConfigSchema with transport, http.port, http.host, http.path fields"
      contains: "serve:"
    - path: "src/cli/index.ts"
      provides: "serve command with --transport, --port, --host flags"
      contains: "--transport"
    - path: "src/cli/serve.ts"
      provides: "runServe accepting CLI opts and branching on resolved transport mode"
      contains: "transport"
  key_links:
    - from: "src/cli/index.ts"
      to: "src/cli/serve.ts"
      via: "CLI opts passed to runServe"
      pattern: "runServe\\(opts\\)"
    - from: "src/cli/serve.ts"
      to: "src/config/schema.ts"
      via: "loadConfig with CLI overrides for serve block"
      pattern: "loadConfig"
---

<objective>
Add transport mode configuration and CLI flags to `handover serve` so the command can select between stdio (default) and HTTP transport.

Purpose: Establish the config schema, CLI surface, and serve branching logic that Plan 02 will use to wire the actual HTTP transport implementation.
Output: Updated config schema with `serve` block, CLI serve command with `--transport`/`--port`/`--host` flags, and `runServe()` branching on resolved transport mode.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-http-transport-parity/19-CONTEXT.md
@.planning/phases/19-http-transport-parity/19-RESEARCH.md
@src/config/schema.ts
@src/config/loader.ts
@src/cli/index.ts
@src/cli/serve.ts
@src/mcp/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config schema with serve transport block</name>
  <files>src/config/schema.ts</files>
  <action>
Add a `ServeConfigSchema` Zod object inside `src/config/schema.ts` with the following structure:

```typescript
const ServeConfigSchema = z
  .object({
    transport: z.enum(['stdio', 'http']).default('stdio'),
    http: z
      .object({
        port: z.number().int().min(1).max(65535).default(3000),
        host: z.string().default('127.0.0.1'),
        path: z.string().regex(/^\//).default('/mcp'),
      })
      .default({}),
  })
  .default({});
```

Add `serve: ServeConfigSchema` to the `HandoverConfigSchema` z.object fields. Place it after the `embedding` field.

This follows the existing config schema pattern (nested objects with `.default({})` for zero-config mode). The `serve` block defaults to `{ transport: 'stdio', http: { port: 3000, host: '127.0.0.1', path: '/mcp' } }`.

Per locked decisions:
- `stdio` is the default transport (no config required for existing users)
- HTTP mode is opt-in via config or CLI flags
- `/mcp` is the default and only MCP endpoint path (no alias paths)
- One transport per process
  </action>
  <verify>Run `npm run typecheck` — must pass with no errors. Verify `HandoverConfig` type now includes `serve.transport`, `serve.http.port`, `serve.http.host`, `serve.http.path`.</verify>
  <done>HandoverConfigSchema includes a `serve` block with transport enum defaulting to stdio, and an http sub-block with port/host/path defaults. Existing configs without a `serve` key still parse successfully with all defaults applied.</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI flags and wire transport-branched serve startup</name>
  <files>src/cli/index.ts, src/cli/serve.ts, src/mcp/server.ts</files>
  <action>
**In `src/cli/index.ts`:**

Update the `serve` command registration to:
1. Change description to `'Start MCP server over stdio (default) or HTTP transport'`
2. Add `--transport <transport>` option: `'Transport mode: stdio (default) or http'`
3. Add `--port <port>` option with `Number.parseInt` parser: `'HTTP listen port (default: 3000)'`
4. Add `--host <host>` option: `'HTTP listen host (default: 127.0.0.1)'`
5. Pass `opts` to `runServe(opts)` in the action handler (currently passes no args)

Follow the existing Commander pattern used by `generate`, `reindex`, and `search` commands.

**In `src/cli/serve.ts`:**

1. Update `runServe` signature to accept an options object:
   ```typescript
   interface ServeCliOptions {
     transport?: string;
     port?: number;
     host?: string;
   }
   export async function runServe(opts: ServeCliOptions = {}): Promise<void>
   ```

2. Build CLI overrides using per-field precedence so that CLI flags override individual fields without dropping unrelated config values. The key concern: `loadConfig` shallow-merges `cliOverrides` onto file config at the top level, so passing `{ serve: { http: { port: 8080 } } }` would wholesale-replace the entire `serve` object from `.handover.yml`, silently dropping `serve.transport` if it was set in config but not on the CLI. To fix this, pre-load the file config to read existing serve values and build a complete override object where CLI values take precedence and config values serve as fallback:
   ```typescript
   // Pre-read file config to get existing serve values as fallback
   const baseConfig = loadConfig(); // no overrides — just file + env + defaults
   const existingServe = baseConfig.serve;

   const cliOverrides: Record<string, unknown> = {};
   if (opts.transport !== undefined || opts.port !== undefined || opts.host !== undefined) {
     // Per-field precedence: CLI value ?? existing config value
     const serveOverride: Record<string, unknown> = {
       transport: opts.transport ?? existingServe.transport,
       http: {
         port: opts.port ?? existingServe.http.port,
         host: opts.host ?? existingServe.http.host,
         path: existingServe.http.path, // no CLI flag for path; always preserve config
       },
     };
     cliOverrides.serve = serveOverride;
   }
   const config = loadConfig(cliOverrides);
   ```
   This ensures that running `handover serve --port 8080` when `.handover.yml` has `serve.transport: http` preserves the HTTP transport instead of silently reverting to stdio. Per locked decision #2, CLI overrides config on a per-field basis — not wholesale replacement of the nested serve object.

3. After config is loaded and preflight passes, branch on `config.serve.transport`:
   - If `'stdio'`: call `startMcpServer({ registerHooks })` and emit the existing stdio readiness message (unchanged behavior).
   - If `'http'`: call a new `startMcpHttpServer()` function (to be implemented in Plan 02). For now, add the import and call site but expect it to be a placeholder — import from `'../mcp/server.js'`. The call should pass `{ registerHooks, port: config.serve.http.port, host: config.serve.http.host, mcpPath: config.serve.http.path }`.
   - After the HTTP server starts, emit an HTTP-specific startup summary to stderr (per locked decision: transport, base URL, MCP path):
     ```typescript
     writeToStderr('MCP server listening over HTTP.');
     writeToStderr(`Transport: http`);
     writeToStderr(`Base URL: http://${config.serve.http.host}:${config.serve.http.port}`);
     writeToStderr(`MCP path: ${config.serve.http.path}`);
     writeToStderr(`Endpoint: http://${config.serve.http.host}:${config.serve.http.port}${config.serve.http.path}`);
     writeToStderr('Ready: POST/GET/DELETE requests accepted at MCP endpoint.');
     ```

Important: The existing stdio readiness messages MUST remain unchanged for backward compatibility. Only add new HTTP messages in the HTTP branch.

Add the `startMcpHttpServer` stub and its options interface to `src/mcp/server.ts` so the import from `serve.ts` resolves and typecheck passes. Plan 02 will replace this stub with the real implementation. Add the following exports to `server.ts`:
```typescript
export interface StartMcpHttpServerOptions extends CreateMcpServerOptions {
  port?: number;
  host?: string;
  mcpPath?: string;
}

export async function startMcpHttpServer(_options: StartMcpHttpServerOptions = {}): Promise<void> {
  throw new Error('HTTP transport not yet implemented');
}
```
  </action>
  <verify>Run `npm run typecheck` — must pass. Run `npm test` — all existing tests must pass. Verify that `handover serve --help` shows `--transport`, `--port`, and `--host` options.</verify>
  <done>CLI serve command accepts --transport, --port, and --host flags. runServe branches on resolved config.serve.transport. stdio path is unchanged. HTTP path calls startMcpHttpServer (stub) and emits endpoint summary to stderr. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm test` passes with no regressions
3. `handover serve --help` shows --transport, --port, --host options
4. HandoverConfigSchema.safeParse({}) succeeds and includes serve defaults (transport: 'stdio', http: { port: 3000, host: '127.0.0.1', path: '/mcp' })
5. HandoverConfigSchema.safeParse({ serve: { transport: 'http' } }) succeeds with transport set to 'http'
</verification>

<success_criteria>
- Config schema extended with serve block (transport + http sub-block)
- CLI serve command shows transport/port/host flags
- runServe branches between stdio and HTTP based on resolved transport config
- stdio behavior is unchanged — no regression for existing users
- typecheck and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-http-transport-parity/19-01-SUMMARY.md`
</output>
