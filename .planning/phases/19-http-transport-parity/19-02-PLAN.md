---
phase: 19-http-transport-parity
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/mcp/server.ts
  - docs/src/content/docs/user/mcp-setup.md
autonomous: true

must_haves:
  truths:
    - "User can start handover serve --transport http and the server listens on the configured port"
    - "User can POST/GET/DELETE to /mcp endpoint and receive MCP protocol responses"
    - "User requesting an unknown HTTP path receives a 404 with guidance to the configured MCP path"
    - "HTTP and stdio expose the same MCP tools, resources, and prompts"
    - "MCP setup docs explain how to start and connect to the HTTP transport"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "startMcpHttpServer with Express app, route handlers, and 404 handler"
      exports: ["startMcpHttpServer", "StartMcpHttpServerOptions"]
    - path: "docs/src/content/docs/user/mcp-setup.md"
      provides: "HTTP transport setup instructions"
      contains: "http"
  key_links:
    - from: "src/cli/serve.ts"
      to: "src/mcp/server.ts"
      via: "startMcpHttpServer call with port/host/mcpPath"
      pattern: "startMcpHttpServer"
    - from: "src/mcp/server.ts"
      to: "@modelcontextprotocol/sdk/server/streamableHttp.js"
      via: "StreamableHTTPServerTransport import"
      pattern: "StreamableHTTPServerTransport"
    - from: "src/mcp/server.ts"
      to: "@modelcontextprotocol/sdk/server/express.js"
      via: "createMcpExpressApp import"
      pattern: "createMcpExpressApp"
---

<objective>
Implement the HTTP transport server function using the MCP SDK's StreamableHTTPServerTransport, replacing the stub from Plan 01 with a working Express-based HTTP endpoint.

Purpose: Give users a working HTTP transport path that exposes the exact same MCP capability surface (tools, resources, prompts) as stdio. This completes the transport parity requirement.
Output: Working `startMcpHttpServer()` in server.ts, updated MCP setup docs with HTTP instructions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-http-transport-parity/19-CONTEXT.md
@.planning/phases/19-http-transport-parity/19-RESEARCH.md
@.planning/phases/19-http-transport-parity/19-01-SUMMARY.md
@src/mcp/server.ts
@src/cli/serve.ts
@docs/src/content/docs/user/mcp-setup.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement startMcpHttpServer with Streamable HTTP transport</name>
  <files>src/mcp/server.ts</files>
  <action>
Replace the placeholder `startMcpHttpServer` stub (from Plan 01) with the full implementation. Keep the existing `StartMcpHttpServerOptions` interface and `startMcpServer`/`createMcpServer` exports unchanged.

**Implementation:**

```typescript
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { createMcpExpressApp } from '@modelcontextprotocol/sdk/server/express.js';
import { createServer } from 'node:http';
```

Add these imports at the top of `server.ts` alongside the existing SDK imports. Use `.js` extensions per NodeNext moduleResolution.

Replace the stub body with:

```typescript
export async function startMcpHttpServer(options: StartMcpHttpServerOptions = {}): Promise<void> {
  const server = createMcpServer(options);
  const host = options.host ?? '127.0.0.1';
  const port = options.port ?? 3000;
  const mcpPath = options.mcpPath ?? '/mcp';

  const app = createMcpExpressApp({ host });

  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined, // stateless: simpler, no session memory leaks
  });

  await server.connect(transport);

  // Register all three MCP HTTP verbs on the canonical path
  app.post(mcpPath, async (req, res) => {
    await transport.handleRequest(req, res, req.body);
  });

  app.get(mcpPath, async (req, res) => {
    await transport.handleRequest(req, res);
  });

  app.delete(mcpPath, async (req, res) => {
    await transport.handleRequest(req, res);
  });

  // Unknown paths: strict 404 with remediation guidance (per locked decision)
  app.use((_req, res) => {
    res.status(404).json({
      ok: false,
      error: {
        code: 'MCP_HTTP_NOT_FOUND',
        message: 'Unknown HTTP path.',
        action: `MCP requests must target ${mcpPath}. No alias paths are supported.`,
      },
    });
  });

  // Bind HTTP server
  await new Promise<void>((resolve, reject) => {
    const httpServer = createServer(app);
    httpServer.listen(port, host, resolve);
    httpServer.on('error', reject);
  });
}
```

Key decisions per locked context:
- **Stateless transport** (`sessionIdGenerator: undefined`): Each request is independent. The MCP tool layer manages state internally (QA sessions, regeneration jobs). No transport-level session tracking needed.
- **`createMcpExpressApp({ host })`**: SDK automatically applies DNS rebinding protection via `localhostHostValidation()` for localhost-bound servers. No custom Host header checking needed.
- **Three verb handlers** (POST, GET, DELETE) on the single canonical `mcpPath`: POST for JSON-RPC, GET for SSE subscription, DELETE for session close. All delegate to `transport.handleRequest`.
- **404 handler**: Uses the project's established structured error pattern (`ok: false, error: { code, message, action }`). Guides clients to the configured MCP path.
- **`req.body` pass-through** on POST: `createMcpExpressApp` includes `express.json()` middleware that pre-parses the body. Pass `req.body` as third arg to avoid double-reading the stream.
- **No `@types/express` install**: Express 5 types come from the SDK. The project's `skipLibCheck: true` handles any residual type declaration issues.

Do NOT install any new npm packages. All dependencies are already available via the MCP SDK.

If TypeScript complains about Express types (e.g., `req`/`res` parameter types), use inline type annotations or import types from the SDK's Express re-exports. If `createMcpExpressApp` returns an untyped app, you may need `as any` casts on the route handlers — this is acceptable given Express 5 type landscape and `skipLibCheck: true`.
  </action>
  <verify>Run `npm run typecheck` — must pass. Run `npm test` — all existing tests must pass. Manually verify the implementation by reading server.ts and confirming: (1) three verb handlers registered on mcpPath, (2) 404 fallback handler present, (3) stateless transport configured, (4) createMcpExpressApp used with host parameter.</verify>
  <done>startMcpHttpServer creates an Express app via SDK, registers POST/GET/DELETE on /mcp, adds 404 handler with remediation, and binds an HTTP server on the configured port/host. typecheck and all tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update MCP setup docs with HTTP transport instructions</name>
  <files>docs/src/content/docs/user/mcp-setup.md</files>
  <action>
Add a new section to the MCP setup docs for HTTP transport mode. Place it after the existing stdio setup sections but before any troubleshooting or FAQ sections.

Add a section titled `## HTTP Transport Mode` (or similar, matching the doc's existing heading style) with the following content:

1. **Overview**: Explain that `handover serve` defaults to stdio but can run over Streamable HTTP for remote/hosted deployment scenarios.

2. **Starting HTTP mode**:
   ```bash
   # Start with HTTP transport
   handover serve --transport http

   # Customize port and host
   handover serve --transport http --port 8080

   # Or via .handover.yml config:
   ```
   ```yaml
   serve:
     transport: http
     http:
       port: 3000
       host: 127.0.0.1
       path: /mcp
   ```

3. **Endpoint discovery**: When HTTP mode starts, the server prints an endpoint summary to stderr:
   ```
   MCP server listening over HTTP.
   Transport: http
   Base URL: http://127.0.0.1:3000
   MCP path: /mcp
   Endpoint: http://127.0.0.1:3000/mcp
   Ready: POST/GET/DELETE requests accepted at MCP endpoint.
   ```

4. **Connecting MCP clients**: Explain that MCP clients that support Streamable HTTP can connect to the endpoint URL. Provide a brief example of configuring a client to use `http://127.0.0.1:3000/mcp`.

5. **Parity note**: State that HTTP and stdio expose the same tools, resources, and prompts — no functional differences between transports.

6. **CLI flag precedence**: Note that `--transport` and `--port` CLI flags override `.handover.yml` config for the current run.

Match the existing doc's tone and formatting style. Keep it concise and operational — no lengthy explanations. The audience is a developer who wants to start the server over HTTP quickly.
  </action>
  <verify>Read the updated docs file and confirm the HTTP transport section is present with: startup command examples, config YAML example, endpoint summary example, parity statement, and CLI precedence note.</verify>
  <done>MCP setup docs include a complete HTTP transport section with startup commands, config examples, endpoint discovery output, client connection guidance, and transport parity statement.</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm test` passes with no regressions
3. `src/mcp/server.ts` exports `startMcpHttpServer` with Express app, three route handlers, and 404 fallback
4. `docs/src/content/docs/user/mcp-setup.md` contains HTTP transport setup section
5. No new npm packages installed (all dependencies via existing MCP SDK)
</verification>

<success_criteria>
- startMcpHttpServer creates Express app via SDK, registers POST/GET/DELETE on configured path, adds 404 handler
- Stateless StreamableHTTPServerTransport used (sessionIdGenerator: undefined)
- createMcpExpressApp provides DNS rebinding protection automatically
- HTTP and stdio share the same McpServer created by createMcpServer (same tools/resources/prompts)
- MCP setup docs updated with HTTP transport instructions
- typecheck and all tests pass
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/19-http-transport-parity/19-02-SUMMARY.md`
</output>
