---
phase: 04-cache-correctness
plan: 1
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cache/round-cache.ts
  - src/cli/generate.ts
autonomous: true

must_haves:
  truths:
    - 'Editing a file without changing its size causes the cached analysis fingerprint to differ, triggering re-analysis'
    - 'Re-running handover after Round 1 output changes causes Rounds 2-6 to produce different cache keys and re-execute'
    - 'A re-run on a completely unchanged codebase produces identical cache keys and serves all rounds from cache'
    - 'Running with --no-cache skips reading cache but preserves cache files on disk for the next normal run'
    - 'The .handover/cache directory is automatically added to .gitignore on first cache write'
  artifacts:
    - path: 'src/cache/round-cache.ts'
      provides: 'Content-hash fingerprint, cascade hash chain, version-aware cache entries, auto-gitignore'
      contains: 'contentHash'
    - path: 'src/cli/generate.ts'
      provides: 'Content hash computation at call site, prior round hash threading, --no-cache preserve behavior'
      contains: 'priorRoundHashes'
  key_links:
    - from: 'src/cli/generate.ts'
      to: 'src/cache/round-cache.ts'
      via: 'computeAnalysisFingerprint with contentHash objects'
      pattern: 'computeAnalysisFingerprint'
    - from: 'src/cli/generate.ts'
      to: 'src/cache/round-cache.ts'
      via: 'computeHash with priorRoundHashes parameter'
      pattern: 'computeHash.*priorRoundHashes'
    - from: 'src/cli/generate.ts'
      to: 'src/analyzers/cache.ts'
      via: 'hashContent reuse for file content hashing'
      pattern: 'hashContent'
---

<objective>
Replace the size-only cache fingerprint with SHA-256 content hashing (CACHE-01), implement cascade invalidation via hash chain (CACHE-02), fix --no-cache to preserve cache files, and auto-add cache directory to .gitignore.

Purpose: These are the two core correctness fixes. Without content hashing, same-size edits serve stale cache. Without cascade invalidation, upstream round changes don't propagate to downstream rounds. The --no-cache and auto-gitignore changes are locked user decisions that belong alongside the core cache logic.

Output: Updated `round-cache.ts` with content-hash fingerprint, cascade hash chain, version field, and auto-gitignore. Updated `generate.ts` with content hash computation, prior round hash threading, and non-destructive --no-cache.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/cache/round-cache.ts
@src/cli/generate.ts
@src/analyzers/cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Content-hash fingerprint, cascade hash chain, version field, and auto-gitignore in RoundCache</name>
  <files>src/cache/round-cache.ts</files>
  <action>
Modify `src/cache/round-cache.ts` with the following changes:

1. **Import `hashContent` from `../analyzers/cache.js`** — reuse the existing SHA-256 helper rather than duplicating it. Also import `writeFile` from `node:fs/promises` (already imported) for gitignore writing.

2. **Change `computeAnalysisFingerprint` signature** from `Array<{ path: string; size: number }>` to `Array<{ path: string; contentHash: string }>`. Update the map to use `f.contentHash` instead of `f.size`. This is the CACHE-01 fix — TypeScript will flag the call site in `generate.ts` ensuring both sides are updated.

3. **Add `priorRoundHashes` parameter to `computeHash`** with default `[]`. Include it in the JSON.stringify object: `{ roundNumber, model, analysisFingerprint, priorRoundHashes }`. This is the CACHE-02 fix — adding a new field changes the hash for all existing cache entries (intentional migration).

4. **Add static `computeResultHash` method** that takes `result: unknown` and returns `createHash('sha256').update(JSON.stringify(result)).digest('hex')`. This is used by the caller to hash a round's output for cascade.

5. **Add `version` field to `RoundCacheEntry` interface**: `version: number`. Define `const CACHE_VERSION = 2;` at module level.

6. **Update `get()` method**: After parsing the entry, check `entry.version !== CACHE_VERSION`. If version mismatch detected and `!this.migrationHandled`, set `this.migrationHandled = true`, call `await this.clear()`, and return `null`. If version matches but hash doesn't match, return `null` as before. Add `private migrationHandled = false;` to the class.

7. **Update `set()` method**: Include `version: CACHE_VERSION` in the stored entry object. After writing the round file, call `await this.ensureGitignored()`.

8. **Update constructor**: Accept optional `projectRoot` parameter (default `process.cwd()`), store as `private readonly projectRoot`. Keep `cacheDir` as first parameter with same default.

9. **Add `ensureGitignored()` private method**: Check a `private _gitignoreChecked = false` flag to run only once. Read `.gitignore` from `this.projectRoot`. Check if any line (trimmed) equals `.handover/cache` or `.handover/`. If not present, append `\n.handover/cache\n` (with leading newline if content doesn't end with newline). Wrap in try/catch — non-fatal if write fails.

10. **Add `get wasMigrated(): boolean`** getter that returns `this.migrationHandled`. This allows the caller to check if a migration occurred and display the warning message.
    </action>
    <verify>
    Run `npx tsc --noEmit` — expect a type error at the `generate.ts` call site for `computeAnalysisFingerprint` (signature changed from `size: number` to `contentHash: string`). This confirms the interface boundary is correctly enforced. The error will be resolved in Task 2.
    </verify>
    <done>
    `RoundCache.computeAnalysisFingerprint` accepts `contentHash` instead of `size`. `computeHash` accepts `priorRoundHashes`. `computeResultHash` exists for cascade. Cache entries have `version` field. `get()` handles version mismatch with migration. `set()` includes version and auto-gitignore. Constructor accepts `projectRoot`.
    </done>
    </task>

<task type="auto">
  <name>Task 2: Update generate.ts call sites — content hashing, cascade threading, --no-cache fix</name>
  <files>src/cli/generate.ts</files>
  <action>
Modify `src/cli/generate.ts` with the following changes:

1. **Import `hashContent` from `../analyzers/cache.js`** and `readFile` from `node:fs/promises` (readFile already imported). Import `existsSync` from `node:fs` if not already present (check — it may not be imported yet).

2. **Fix fingerprint computation in the `static-analysis` step execute**:
   Replace the current file entry mapping:

   ```
   const fileEntries = result.fileTree.directoryTree
     .filter((e) => e.type === 'file')
     .map((f) => ({ path: f.path, size: f.size ?? 0 }));
   ```

   With content-hash computation:

   ```
   const discovered = result.fileTree.directoryTree.filter((e) => e.type === 'file');
   const fileEntries = await Promise.all(
     discovered.map(async (f) => {
       try {
         const content = await readFile(join(rootDir, f.path));
         return { path: f.path, contentHash: hashContent(content) };
       } catch {
         // Unreadable file: use empty hash as fallback
         return { path: f.path, contentHash: '' };
       }
     }),
   );
   ```

   Keep the `analysisFingerprint = RoundCache.computeAnalysisFingerprint(fileEntries);` call — it now works with the updated signature.

3. **Update `RoundCache` constructor call**: Pass `rootDir` as projectRoot:

   ```
   const roundCache = new RoundCache(undefined, rootDir);
   ```

   Note: the constructor signature is `(cacheDir?, projectRoot?)` from Task 1.

   Wait — `rootDir` is defined after the static-only early return. The `RoundCache` is constructed before the static-only check. Move the RoundCache construction to after `const rootDir = resolve(process.cwd());` (line ~237) which is after the static-only block. Actually, `rootDir` for the non-static path is already defined at line 237. The `RoundCache` is created at line 219, before `rootDir` is declared. Solution: use `resolve(process.cwd())` directly in the constructor call, OR move the `const projectRoot = resolve(process.cwd());` declaration earlier. The simplest fix: pass `resolve(process.cwd())` directly since that's what `rootDir` resolves to:

   ```
   const roundCache = new RoundCache(undefined, resolve(process.cwd()));
   ```

4. **Fix `--no-cache` behavior**: Replace the current:

   ```
   if (options.cache === false) {
     await roundCache.clear();
   }
   ```

   With a `noCacheMode` flag:

   ```
   const noCacheMode = options.cache === false;
   ```

   Do NOT call `roundCache.clear()` here. Instead, thread `noCacheMode` into `wrapWithCache`.

5. **Update `wrapWithCache` signature and logic**:
   Change the function signature to accept a third parameter `priorRoundNums: number[]`:

   ```
   const wrapWithCache = (roundNum: number, step: StepDefinition, priorRoundNums: number[]): StepDefinition => {
   ```

   Inside the execute callback:
   - Build prior round hashes:
     ```
     const priorHashes = priorRoundNums.map((n) => {
       const prior = roundResults.get(n);
       if (!prior) return '';
       return RoundCache.computeResultHash(prior);
     });
     ```
   - Compute hash with cascade:
     ```
     const hash = roundCache.computeHash(roundNum, modelName, analysisFingerprint, priorHashes);
     ```
   - Gate cache reads on `noCacheMode`:
     ```
     if (!noCacheMode) {
       const cached = await roundCache.get(roundNum, hash);
       if (cached) {
         // ... existing cache hit logic ...
         return cached;
       }
     }
     ```
   - Cache writes always happen (even in no-cache mode) — the result is stored for future normal runs.

6. **Update all `wrapWithCache` call sites** with the correct `priorRoundNums` arrays derived from the actual round dependency structure (which rounds each step consumes as context):
   - Round 1: `wrapWithCache(1, step, [])` — no prior rounds
   - Round 2: `wrapWithCache(2, step, [1])` — uses Round 1
   - Round 3: `wrapWithCache(3, step, [1, 2])` — uses Rounds 1+2
   - Round 4: `wrapWithCache(4, step, [1, 2, 3])` — uses Rounds 1+2+3
   - Round 5: `wrapWithCache(5, step, [1, 2])` — uses Rounds 1+2 (verified from getRound calls)
   - Round 6: `wrapWithCache(6, step, [1, 2])` — uses Rounds 1+2 (verified from getRound calls)
     </action>
     <verify>
7. Run `npx tsc --noEmit` — should pass with zero errors (both sides of the interface updated).
8. Run `npm test` — all existing tests should pass.
9. Verify the `--no-cache` change: search for `roundCache.clear()` in generate.ts — it should NOT appear in the `--no-cache` conditional block (it may still exist as a method on the class for migration use).
   </verify>
   <done>
   `generate.ts` computes SHA-256 content hashes for all discovered files. Each `wrapWithCache` call passes the correct `priorRoundNums` for cascade invalidation. `--no-cache` skips cache reads but preserves files. Cache writes always happen. TypeScript compiles cleanly. All tests pass.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no type errors across the entire project
2. `npm test` passes — no regressions in existing test suite
3. `grep -n "computeAnalysisFingerprint" src/cache/round-cache.ts` shows `contentHash: string` in signature
4. `grep -n "priorRoundHashes" src/cache/round-cache.ts` shows the parameter in `computeHash`
5. `grep -n "noCacheMode" src/cli/generate.ts` shows the flag is used to gate cache reads
6. `grep -n "roundCache.clear()" src/cli/generate.ts` does NOT appear in the `--no-cache` block
7. `grep -n "ensureGitignored" src/cache/round-cache.ts` confirms auto-gitignore method exists
</verification>

<success_criteria>

- CACHE-01: `computeAnalysisFingerprint` uses `contentHash` (SHA-256 of file content) instead of `size`
- CACHE-02: `computeHash` includes `priorRoundHashes` forming a hash chain across rounds
- `--no-cache` preserves cache files on disk (no `clear()` call)
- Cache entries include `version: 2` field; old entries without version are cleared with migration warning
- `.handover/cache` is auto-added to `.gitignore` on first cache write
- All existing tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/04-cache-correctness/04-01-SUMMARY.md`
</output>
