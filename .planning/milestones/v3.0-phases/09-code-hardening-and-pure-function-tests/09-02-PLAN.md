---
phase: 09-code-hardening-and-pure-function-tests
plan: 02
type: execute
wave: 2
depends_on: ['09-01']
files_modified:
  - src/context/scorer.test.ts
  - src/context/token-counter.test.ts
autonomous: true

must_haves:
  truths:
    - 'vitest run reports passing tests for scoreFiles() covering all 6 scoring factors'
    - 'vitest run reports passing tests for computeTokenBudget() with edge cases'
    - 'vitest run reports passing tests for estimateTokens() with and without provider'
  artifacts:
    - path: 'src/context/scorer.test.ts'
      provides: 'Unit tests for scoreFiles()'
      contains: 'test.each'
    - path: 'src/context/token-counter.test.ts'
      provides: 'Unit tests for computeTokenBudget() and estimateTokens()'
      contains: 'describe'
  key_links:
    - from: 'src/context/scorer.test.ts'
      to: 'src/context/scorer.ts'
      via: 'imports scoreFiles and named constants'
      pattern: 'import.*scoreFiles.*SCORE_'
    - from: 'src/context/token-counter.test.ts'
      to: 'src/context/token-counter.ts'
      via: 'imports computeTokenBudget and estimateTokens'
      pattern: 'import.*computeTokenBudget.*estimateTokens'
---

<objective>
Write table-driven unit tests for scoreFiles(), computeTokenBudget(), and estimateTokens() using test.each with explicit assertions.

Purpose: Regression-protect the scoring algorithm and token budget computation — the two core pure functions that determine which files get included in LLM context.
Output: Two test files co-located with source: scorer.test.ts and token-counter.test.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/context/scorer.ts
@src/context/token-counter.ts
@src/context/types.ts
@src/analyzers/types.ts
@.planning/phases/09-code-hardening-and-pure-function-tests/09-RESEARCH.md
@.planning/phases/09-code-hardening-and-pure-function-tests/09-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write scoreFiles() unit tests</name>
  <files>src/context/scorer.test.ts</files>
  <action>
Create `src/context/scorer.test.ts` co-located with `scorer.ts`.

**Import the function and named constants:**

```typescript
import { describe, expect, test } from 'vitest';
import {
  scoreFiles,
  SCORE_ENTRY_POINT,
  SCORE_IMPORT_PER_IMPORTER,
  SCORE_IMPORT_CAP,
  SCORE_EXPORT_PER_EXPORT,
  SCORE_EXPORT_CAP,
  SCORE_GIT_ACTIVITY_CAP,
  SCORE_EDGE_CASES,
  SCORE_CONFIG_FILE,
  SCORE_TEST_PENALTY,
  SCORE_MIN,
  SCORE_MAX,
} from './scorer.js';
```

**Build a `buildMockAnalysis()` factory helper** inside the test file (NOT shared). This constructs a minimal valid `StaticAnalysisResult` with sensible defaults. Read `src/analyzers/types.ts` first to understand the exact type shape. The factory should accept partial overrides for:

- `files`: Array of `{ path, type }` for `fileTree.directoryTree`
- `gitChangedFiles`: Array of `{ path, changes }` for `gitHistory.mostChangedFiles`
- `todoItems`: Array of `{ file }` for `todos.items`
- `astFiles`: Array of `{ path, imports, exports }` for `ast.files`

Cast the result through `as unknown as StaticAnalysisResult` since we only need the fields scoreFiles actually reads.

**Test cases to cover (use `test.each` where marked):**

1. **Empty input:** Returns empty array for empty file tree
2. **Lock file exclusion:** Excludes package-lock.json, yarn.lock, pnpm-lock.yaml (test.each with 3 lock filenames)
3. **Entry point detection (test.each):** index.ts, main.js, src/index.ts get SCORE_ENTRY_POINT bonus; utils.ts gets 0
4. **Import count scoring:** A file imported by 5 others gets `Math.min(5 * SCORE_IMPORT_PER_IMPORTER, SCORE_IMPORT_CAP)`. Test cap enforcement: file imported by 20 others gets SCORE_IMPORT_CAP not 60
5. **Export count scoring:** File with 15 exports gets `Math.min(15 * SCORE_EXPORT_PER_EXPORT, SCORE_EXPORT_CAP)` = SCORE_EXPORT_CAP
6. **Git activity scoring:** File with 5 changes gets 5; file with 50 changes gets SCORE_GIT_ACTIVITY_CAP
7. **Edge cases (TODOs):** File with TODO items gets SCORE_EDGE_CASES; file without gets 0
8. **Config file detection:** package.json, .eslintrc.js get SCORE_CONFIG_FILE bonus
9. **Test file penalty:** utils.test.ts gets penalized by SCORE_TEST_PENALTY; score floors at SCORE_MIN
10. **Score cap:** Construct a file that would exceed 100 without cap (entry point + high imports + high exports + git + todos + config). Verify score <= SCORE_MAX
11. **Sort order:** Three files with different scores return sorted descending; tied scores sort alphabetically

Use the named constants in assertions to document the formula (e.g., `expect(result[0].breakdown.entryPoint).toBe(SCORE_ENTRY_POINT)` not `toBe(30)`).

For import count testing: construct the astFiles array with import records that reference the target file path. The `buildReverseImportMap` inside scorer.ts resolves relative imports, so create import sources like `'./target'` from files in the same directory.
</action>
<verify>
Run `npx vitest run src/context/scorer.test.ts` — all tests pass. Run `npx tsc --noEmit` — no type errors.
</verify>
<done>
scorer.test.ts exists with tests covering all 6 scoring factors (entry point, import count, export count, git activity, edge cases, config file), the test file penalty, score capping, lock file exclusion, and sort order. All tests use named constants in assertions.
</done>
</task>

<task type="auto">
  <name>Task 2: Write computeTokenBudget() and estimateTokens() unit tests</name>
  <files>src/context/token-counter.test.ts</files>
  <action>
Create `src/context/token-counter.test.ts` co-located with `token-counter.ts`.

**Import:**

```typescript
import { describe, expect, test } from 'vitest';
import { computeTokenBudget, estimateTokens } from './token-counter.js';
```

**computeTokenBudget() tests:**

1. **Default values for standard 100k window:**

   ```typescript
   const result = computeTokenBudget(100_000);
   expect(result.total).toBe(100_000);
   expect(result.promptOverhead).toBe(3000);
   expect(result.outputReserve).toBe(4096);
   expect(result.fileContentBudget).toBe(Math.floor((100_000 - 3000 - 4096) * 0.9));
   ```

2. **test.each with custom options** — multiple window sizes and custom overrides:

   ```
   { maxTokens: 8_000, default options }
   { maxTokens: 200_000, default options }
   { maxTokens: 16_000, overhead: 5000, reserve: 2048, margin: 0.8 }
   ```

   For each: `expect(result.fileContentBudget).toBe(Math.floor((maxTokens - overhead - reserve) * margin))` — compute the expected value inline using the same formula to document the calculation.

3. **Zero maxTokens:** Verify behavior when maxTokens is 0 (budget goes negative). Document the actual behavior without judgment — this tests that the function doesn't throw.

4. **Overhead exceeds window:** maxTokens=1000, overhead=500, reserve=600. The intermediate is negative: `(1000 - 500 - 600) * 0.9 = -90`. Document this behavior with a comment: the function does not guard against negative; test documents actual behavior.

5. **All-zero options:** `computeTokenBudget(100_000, { promptOverhead: 0, outputReserve: 0, safetyMargin: 1.0 })` returns fileContentBudget = 100_000.

**estimateTokens() tests:**

1. **chars/4 heuristic without provider:** `estimateTokens('a'.repeat(400))` returns 100
2. **Empty string:** returns 0
3. **Rounds up fractional:** `estimateTokens('abc')` returns 1 (ceil(3/4))
4. **Single character:** `estimateTokens('x')` returns 1
5. **Delegates to provider:** Pass a mock object `{ estimateTokens: () => 42 } as any` — verify it returns 42 regardless of text content
6. **Long string:** 1 million chars → 250_000 tokens (verify the heuristic scales linearly)
   </action>
   <verify>
   Run `npx vitest run src/context/token-counter.test.ts` — all tests pass. Run `npx tsc --noEmit` — no type errors.
   </verify>
   <done>
   token-counter.test.ts exists with comprehensive tests for computeTokenBudget() (default values, custom options, edge cases with formula documentation) and estimateTokens() (heuristic, empty, fractional, provider delegation). All assertions use computed expected values, not magic numbers.
   </done>
   </task>

</tasks>

<verification>
1. `npx vitest run src/context/scorer.test.ts` — all tests pass
2. `npx vitest run src/context/token-counter.test.ts` — all tests pass
3. Both test files exist at the correct co-located paths
4. `npx tsc --noEmit` passes
5. Tests use `test.each` for combinatorial inputs
6. No snapshot assertions — all explicit `toBe`/`toEqual`
</verification>

<success_criteria>

- scorer.test.ts covers all 6 scoring factors via test.each, lock file exclusion, test penalty, cap, and sort order
- token-counter.test.ts covers default budgets, custom options, edge cases, and provider delegation
- All assertions use named constants or computed values, not raw numbers
- `npx vitest run` reports all tests passing
  </success_criteria>

<output>
After completion, create `.planning/phases/09-code-hardening-and-pure-function-tests/09-02-SUMMARY.md`
</output>
